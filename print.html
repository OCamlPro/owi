<!DOCTYPE HTML>
<html lang="en" class="frappe sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Owi</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="shortcut icon" href="favicon-bb18a52c.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/catppuccin-59297a51.css">
        <link rel="stylesheet" href="theme/tabs-375d3aef.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "frappe";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-8d6285c8.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-66d4629a.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>‚Üê</kbd> or <kbd>‚Üí</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('frappe')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">Owi</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="welcome-to-owi"><a class="header" href="#welcome-to-owi">Welcome to Owi</a></h1>
<p><strong>Owi</strong> is an open-source framework for advanced <a href="https://webassembly.org">WebAssembly</a> analysis and manipulation, with a focus on practical symbolic execution and robust tooling.
It is designed for researchers, engineers, programming language enthusiasts and practitioners requiring precise, flexible, and extensible support program reasoning.</p>
<p>Owi provides three primary components:</p>
<h3 id="-symbolic-execution-engine-for-wasm-c-c-rust-and-zig"><a class="header" href="#-symbolic-execution-engine-for-wasm-c-c-rust-and-zig">üî¨ <a href="symex/overview.html">Symbolic Execution Engine</a> for <a href="symex/quickstart/wasm.html">Wasm</a>, <a href="symex/quickstart/c.html">C</a>, <a href="symex/quickstart/cpp.html">C++</a>, <a href="symex/quickstart/rust.html">Rust</a>, and <a href="symex/quickstart/zig.html">Zig</a></a></h3>
<p>Owi includes a cross-language symbolic execution engine supporting:</p>
<ul>
<li><a href="symex/bugfinding.html"><strong>Automated testing, bug finding and pentesting</strong></a> through symbolic testing and constraint solving;</li>
<li><a href="symex/sap.html"><strong>Solver-aided programming</strong></a> for problem solving and synthesis tasks;</li>
<li><a href="symex/testcase_generation.html"><strong>Test case generation</strong></a> aligned with advanced coverage criteria;</li>
<li><a href="symex/verification.html"><strong>Formal verification</strong></a>: prove properties or find counterexamples in real-world programs.</li>
</ul>
<p>The engine is designed for precision, scalability, interoperability across languages, and extensibility toward both experimental and applied verification use-cases.
It offers a practical path from fuzzing to formal proofs.</p>
<h3 id="-the-wasm-swiss-army-knife"><a class="header" href="#-the-wasm-swiss-army-knife">üîß The <a href="#overview">Wasm Swiss Army Knife</a></a></h3>
<p>Owi offers a set of practical tools for Wasm development and analysis:</p>
<ul>
<li><strong>Formatter</strong> and <strong>optimizer</strong> for Wasm modules;</li>
<li><strong>Interpreter</strong> for <code>.wasm</code>, <code>.wat</code>, and even <a href="https://github.com/WebAssembly/spec/tree/main/interpreter#scripts">Wasm scripts</a>  (<code>.wast</code>) files that are used in the <a href="https://github.com/WebAssembly/spec/blob/main/interpreter/README.md#scripts">reference test suite</a>;</li>
<li><strong>Specification-compliant validator</strong>;</li>
<li><strong>Bidirectional translation</strong> between binary (<code>.wasm</code>) and text (<code>.wat</code>) formats;</li>
<li><strong>Randomized fuzzer</strong> generating valid (well-typed) Wasm modules.</li>
</ul>
<p>These tools aim to support everyday development tasks as well as research on program analysis, fuzzing, and program transformation.</p>
<h3 id="--native-ocaml-library-for-wasm-integration"><a class="header" href="#--native-ocaml-library-for-wasm-integration">üê™  Native <a href="#overview-1">OCaml Library for Wasm</a> Integration</a></h3>
<p>Owi is written in <a href="https://ocaml.org">OCaml</a>, thus it also provides a library for:</p>
<ul>
<li><strong>Embedding Wasm modules</strong> into OCaml applications;</li>
<li><strong>Importing OCaml functions</strong> into Wasm modules with full type safety.</li>
</ul>
<p>This allows for tightly integrating Wasm-based computation within OCaml-based systems while maintaining strong type guarantees.</p>
<h3 id="want-to-join-us"><a class="header" href="#want-to-join-us">üßë‚ÄçüéìWant to join us?</a></h3>
<p>We are looking for interns, have a look at the <a href="https://github.com/OCamlPro/owi/labels/internship">internship labeled issues</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<h2 id="install-from-your-package-manager"><a class="header" href="#install-from-your-package-manager">Install from your package manager</a></h2>
<p>Check on <a href="https://repology.org/project/ocaml%3Aowi/versions">repology</a> if Owi is available in your package manager.</p>
<h3 id="nixos"><a class="header" href="#nixos">NixOS</a></h3>
<pre><code class="language-shell-session">$ nix-shell -p owi
</code></pre>
<h2 id="install-from-sources"><a class="header" href="#install-from-sources">Install from sources</a></h2>
<p><code>owi</code> can be installed with <a href="https://opam.ocaml.org">opam</a>:</p>
<pre><code class="language-shell-session">$ opam install owi
# if you intend to use symbolic execution you must install one solver
# you can choose any solver supported by smtml
# z3, colibri2, bitwuzla-cxx or cvc5 for instance
$ opam install z3
</code></pre>
<p>If you don‚Äôt have <code>opam</code>, you can install it following the <a href="https://opam.ocaml.org/doc/Install.html">how to install opam</a> guide.</p>
<p>If you can‚Äôt or don‚Äôt want to use <code>opam</code>, you can build the package with <code>dune build -p owi @install</code> but you‚Äôll first have to install the dependencies by yourself. You can find the list of dependencies in the <code>dune-project</code> file.</p>
<h3 id="development-version"><a class="header" href="#development-version">Development version</a></h3>
<p>To get the development version:</p>
<pre><code class="language-shell-session">$ git clone git@github.com:OCamlPro/owi.git
$ cd owi
$ opam install . --deps-only
$ dune build -p owi @install
$ dune install
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="supported-wasm-proposals"><a class="header" href="#supported-wasm-proposals">Supported Wasm proposals</a></h1>
<p>See the <a href="https://webassembly.org/features">WebAssembly features</a> page.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="comparison-with-other-tools"><a class="header" href="#comparison-with-other-tools">Comparison with other tools</a></h1>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Tool</th><th>Supported languages</th><th>Automatic</th><th>Falses positives</th><th>Falses negatives</th><th>Bug-finding</th><th>Proof of Program</th><th>Code Coverage</th><th>Licence</th><th>Category</th></tr>
</thead>
<tbody>
<tr><td>Owi</td><td>C, C++, Rust, TinyGo, Wasm, Zig</td><td>Yes</td><td>No</td><td>Only when non terminating</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Free</td><td>Symbolic Execution</td></tr>
<tr><td>KLEE</td><td>C</td><td>Yes</td><td>No</td><td>Yes</td><td>Yes</td><td>No</td><td>Yes</td><td>Free</td><td>Symbolic Execution</td></tr>
<tr><td>Frama-C WP</td><td>C</td><td>No</td><td>No</td><td>No</td><td>No</td><td>Yes</td><td>No</td><td>Free</td><td>Deductive Verification</td></tr>
<tr><td>Frama-C EVA</td><td>C</td><td>Yes</td><td>Yes</td><td>No</td><td>Yes</td><td>Yes</td><td>No</td><td>Free</td><td>Abstract Interpretation</td></tr>
<tr><td>Astr√©e</td><td>C, C++</td><td>Yes</td><td>Yes</td><td>No</td><td>Yes</td><td>Yes</td><td>No</td><td>Proprietary</td><td>Abstract Interpretation</td></tr>
<tr><td>Mopsa</td><td>C, Python3</td><td>Yes</td><td>Yes</td><td>No</td><td>Yes</td><td>Yes</td><td>No</td><td>Free</td><td>Abstract Interpretation</td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="symbolic-execution-101"><a class="header" href="#symbolic-execution-101">Symbolic Execution 101</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="quickstart"><a class="header" href="#quickstart">Quickstart</a></h1>
<h2 id="finding-a-crash-in-a-function"><a class="header" href="#finding-a-crash-in-a-function">Finding a crash in a function</a></h2>
<p>Let‚Äôs say you wrote a function <code>f</code> and want to check if it can crash for some input. The function could for instance be the following one (choose your programming language to get a specialized example):</p>
<div class="mdbook-tabs-container" data-tabglobal="lang">
<nav class="mdbook-tabs">
<button class="mdbook-tab active" data-tabname="C">C</button>
<button class="mdbook-tab" data-tabname="C++">C++</button>
<button class="mdbook-tab" data-tabname="Rust">Rust</button>
<button class="mdbook-tab" data-tabname="Zig">Zig</button>
<button class="mdbook-tab" data-tabname="Wasm">Wasm</button>
</nav>
<div class="mdbook-tab-content" data-tabname="C">
<!-- $MDX file=f.c -->
<pre><code class="language-c">int f(int x) {

  int arr[4] = {1, 2, 0, 4};

  if (x &gt;= 0 &amp;&amp; x &lt; 4) {
    return 10 / arr[x];
  }

  return -1;
}
</code></pre>
</div>

<div class="mdbook-tab-content hidden" data-tabname="C++">
<!-- $MDX file=f.cpp -->
<pre><code class="language-cpp">extern "C" int f(int x) {

  int arr[4] = {1, 2, 0, 4};

  if (x &gt;= 0 &amp;&amp; x &lt; 4) {
    return 10 / arr[x];
  }

  return -1;
}
</code></pre>
</div>

<div class="mdbook-tab-content hidden" data-tabname="Rust">
<!-- $MDX file=f.rs -->
<pre><code class="language-rs">#![no_main]

#[no_mangle]
pub extern "C" fn f(x: usize) -&gt; i32 {

  let arr = [1, 2, 0, 4];

  if x &lt; arr.len() {
    return 10 / arr[x];
  }

  -1
}
</code></pre>
</div>

<div class="mdbook-tab-content hidden" data-tabname="Zig">
<!-- $MDX file=f.zig -->
<pre><code class="language-rs">export fn f(x: usize) i32 {

  const arr = [_]i32{ 1, 2, 0, 4 };

  if (x &lt; arr.len) {
    return @divTrunc(10, arr[x]);
  }

  return -1;
}
</code></pre>
</div>

<div class="mdbook-tab-content hidden" data-tabname="Wasm">
<!-- $MDX file=f.wat -->
<pre><code class="language-wasm">(module
  (memory 1)
  (func $f (export "f") (param $x i32) (result i32)
    (local $value i32)

    (i32.store (i32.mul (i32.const 4) (i32.const 0)) (i32.const 1))
    (i32.store (i32.mul (i32.const 4) (i32.const 1)) (i32.const 2))
    (i32.store (i32.mul (i32.const 4) (i32.const 2)) (i32.const 0))
    (i32.store (i32.mul (i32.const 4) (i32.const 3)) (i32.const 4))

    (if (i32.ge_u (local.get $x) (i32.const 4) )
      (then (return (i32.const -1))))

    (local.set $value
      (i32.load
        (i32.mul
          (local.get $x)
          (i32.const 4))))

    (i32.div_s
      (i32.const 10)
      (local.get $value))
  )
)
</code></pre>
</div>

</div>

<p>We are going to use <code>owi</code> to look for a crash in the function. Owi has one subcommand for each programming language it supports. For instance, if you are analyzing a C program the command will be <code>owi c &lt;...&gt;</code>, whereas for a Rust program it will be <code>owi rust &lt;...&gt;</code>.</p>
<p>Then, we use the <code>--entry-point=f</code> option to tell Owi to starts its analysis on the function we are interested in.</p>
<p>Finally, we use the <code>--invoke-with-symbols</code> option to tell Owi it should invoke the functions with <em>symbolic</em> values. Here, it means that <code>x</code> will be a value representing ‚Äúany possible integer‚Äù, and not a concrete one. You‚Äôll learn more about this in the next example. What you should remember is that it allows Owi to check all possible execution path, for any value of <code>x</code>.</p>
<p>All the others parameters are only here to make the output deterministic while generating the documentation and you should ignore them.</p>
<div class="mdbook-tabs-container" data-tabglobal="lang">
<nav class="mdbook-tabs">
<button class="mdbook-tab active" data-tabname="C">C</button>
<button class="mdbook-tab" data-tabname="C++">C++</button>
<button class="mdbook-tab" data-tabname="Rust">Rust</button>
<button class="mdbook-tab" data-tabname="Zig">Zig</button>
<button class="mdbook-tab" data-tabname="Wasm">Wasm</button>
</nav>
<div class="mdbook-tab-content" data-tabname="C">
<pre><code class="language-sh">$ owi c ./f.c --entry-point=f --invoke-with-symbols --no-assert-failure-expression-printing --verbosity=error
owi: [ERROR] Trap: integer divide by zero
model {
  symbol symbol_0 i32 2
}
owi: [ERROR] Reached problem!
[13]
</code></pre>
</div>

<div class="mdbook-tab-content hidden" data-tabname="C++">
<pre><code class="language-sh">$ owi c++ ./f.cpp --entry-point=f --invoke-with-symbols --no-assert-failure-expression-printing --verbosity=error
owi: [ERROR] Trap: integer divide by zero
model {
  symbol symbol_0 i32 2
}
owi: [ERROR] Reached problem!
[13]
</code></pre>
</div>

<div class="mdbook-tab-content hidden" data-tabname="Rust">
<pre><code class="language-sh">$ owi rust ./f.rs --entry-point=f --invoke-with-symbols --no-assert-failure-expression-printing --verbosity=error
owi: [ERROR] Trap: unreachable
model {
  symbol symbol_0 i32 2
}
owi: [ERROR] Reached problem!
[13]
</code></pre>
</div>

<div class="mdbook-tab-content hidden" data-tabname="Zig">
<pre><code class="language-sh">$ owi zig ./f.zig --entry-point=f --invoke-with-symbols --no-assert-failure-expression-printing --verbosity=error
owi: [ERROR] Trap: unreachable
model {
  symbol symbol_0 i32 2
}
owi: [ERROR] Reached problem!
[13]
</code></pre>
</div>

<div class="mdbook-tab-content hidden" data-tabname="Wasm">
<pre><code class="language-sh">$ owi sym ./f.wat --entry-point=f --invoke-with-symbols --no-assert-failure-expression-printing --verbosity=error
owi: [ERROR] Trap: integer divide by zero
model {
  symbol symbol_0 i32 2
}
owi: [ERROR] Reached problem!
[13]
</code></pre>
</div>

</div>

<p>Owi says he reached a <em>trap</em>, which corresponds to a <em>programming error</em>. The exact trap depends on the input language and how it is compiled to Wasm. But here it‚Äôll either be ‚Äúinteger divide by zero‚Äù or ‚Äúunreachable‚Äù.</p>
<p>Then Owi gives us a <em>model</em>, that is, the set of input values of the program leading to this <em>trap</em>. The model is a list of <em>symbols</em>, each symbols representing an input.</p>
<p>Here we have a single symbol in the model, whose name is <code>symbol_0</code>, of type <code>i32</code> and whose value is <code>2</code>. And indeed, if we use <code>2</code> as the input value of the function <code>f</code>, there will be a crash in the program because of a division by zero!</p>
<h2 id="defining-symbols-by-hand"><a class="header" href="#defining-symbols-by-hand">Defining symbols by hand</a></h2>
<div class="mdbook-tabs-container" data-tabglobal="lang">
<nav class="mdbook-tabs">
<button class="mdbook-tab active" data-tabname="C">C</button>
<button class="mdbook-tab" data-tabname="C++">C++</button>
<button class="mdbook-tab" data-tabname="Rust">Rust</button>
<button class="mdbook-tab" data-tabname="Zig">Zig</button>
<button class="mdbook-tab" data-tabname="Wasm">Wasm</button>
</nav>
<div class="mdbook-tab-content" data-tabname="C">
<p>TODO</p>
</div>

<div class="mdbook-tab-content hidden" data-tabname="C++">
<p>TODO</p>
</div>

<div class="mdbook-tab-content hidden" data-tabname="Rust">
<p>TODO</p>
</div>

<div class="mdbook-tab-content hidden" data-tabname="Zig">
<p>TODO</p>
</div>

<div class="mdbook-tab-content hidden" data-tabname="Wasm">
<p>TODO</p>
</div>

</div>

<div class="mdbook-tabs-container" data-tabglobal="lang">
<nav class="mdbook-tabs">
<button class="mdbook-tab active" data-tabname="C">C</button>
<button class="mdbook-tab" data-tabname="C++">C++</button>
<button class="mdbook-tab" data-tabname="Rust">Rust</button>
<button class="mdbook-tab" data-tabname="Zig">Zig</button>
<button class="mdbook-tab" data-tabname="Wasm">Wasm</button>
</nav>
<div class="mdbook-tab-content" data-tabname="C">
<p>TODO</p>
</div>

<div class="mdbook-tab-content hidden" data-tabname="C++">
<p>TODO</p>
</div>

<div class="mdbook-tab-content hidden" data-tabname="Rust">
<p>TODO</p>
</div>

<div class="mdbook-tab-content hidden" data-tabname="Zig">
<p>TODO</p>
</div>

<div class="mdbook-tab-content hidden" data-tabname="Wasm">
<p>TODO</p>
</div>

</div>

<h2 id="checking-the-equivalence-of-two-functions"><a class="header" href="#checking-the-equivalence-of-two-functions">Checking the equivalence of two functions</a></h2>
<p>Here, we have two functions that we expect to be the same but we are not completely sure. This can be the case for instance when refactoring or optimizing a given function. Owi can check that the old one is equivalent to the new one.</p>
<p>We have the original function, <code>mean_old</code>, that computes the mean of two integers. Then, we define the new function, <code>mean_new</code>, which we expect to do the same. Then, our main function is creating two symbolic integers, <code>n1</code> and <code>n2</code>, and asserts that the two functions always return the same value when given these symbolic integers as input.</p>
<div class="mdbook-tabs-container" data-tabglobal="lang">
<nav class="mdbook-tabs">
<button class="mdbook-tab active" data-tabname="C">C</button>
<button class="mdbook-tab" data-tabname="C++">C++</button>
<button class="mdbook-tab" data-tabname="Rust">Rust</button>
<button class="mdbook-tab" data-tabname="Zig">Zig</button>
<button class="mdbook-tab" data-tabname="Wasm">Wasm</button>
</nav>
<div class="mdbook-tab-content" data-tabname="C">
<!-- $MDX file=mean.c -->
<pre><code class="language-c">#include &lt;owi.h&gt;

int mean1(int x, int y) {
  return (x &amp; y) + ((x ^ y) &gt;&gt; 1);
}

int mean2(int x, int y) {
  return (x + y) / 2;
}

void check(int x, int y) {
  owi_assert(mean1(x, y) == mean2(x, y));
}
</code></pre>
</div>

<div class="mdbook-tab-content hidden" data-tabname="C++">
<!-- $MDX file=mean.cpp -->
<pre><code class="language-cpp">#include &lt;owi.h&gt;

int mean1(int x, int y) {
  return (x &amp; y) + ((x ^ y) &gt;&gt; 1);
}

int mean2(int x, int y) {
  return (x + y) / 2;
}

extern "C" void check(int x, int y) {
  owi_assert(mean1(x, y) == mean2(x, y));
}
</code></pre>
</div>

<div class="mdbook-tab-content hidden" data-tabname="Rust">
<!-- $MDX file=mean.rs -->
<pre><code class="language-rs">#![no_main]

fn mean1(x: i32, y: i32) -&gt; i32 {
    (x &amp; y) + ((x ^ y) &gt;&gt; 1)
}

fn mean2(x: i32, y: i32) -&gt; i32 {
    (x + y) / 2
}

#[no_mangle]
pub extern "C" fn check(x : i32, y: i32) {
  owi_sym::assert(mean1(x, y) == mean2(x, y))
}
</code></pre>
</div>

<div class="mdbook-tab-content hidden" data-tabname="Zig">
<!-- $MDX file=mean.zig -->
<pre><code class="language-rs">extern "owi" fn i32_symbol() i32;
extern "owi" fn assert(bool) void;

fn mean1(x: i32, y: i32) i32 {
  return (x &amp; y) + ((x ^ y) &gt;&gt; 1);
}

fn mean2(x: i32, y: i32) i32 {
  return @divTrunc(x + y, 2);
}

export fn check(x: i32, y: i32) void {
  assert(mean1(x, y) == mean2(x, y));
}
</code></pre>
</div>

<div class="mdbook-tab-content hidden" data-tabname="Wasm">
<!-- $MDX file=mean.wat -->
<pre><code class="language-wasm">(module
  (func $mean1 (param $x i32) (param $y i32) (result i32)
    local.get $x
    local.get $y
    i32.and

    local.get $x
    local.get $y
    i32.xor
    i32.const 1
    i32.shr_s

    i32.add
  )

  (func $mean2 (param $x i32) (param $y i32) (result i32)
    local.get $x
    local.get $y
    i32.add
    i32.const 2
    i32.div_s
  )

  (func $check  (export "check") (param $x i32) (param $y i32)
    local.get $x
    local.get $y
    call $mean1

    local.get $x
    local.get $y
    call $mean2

    i32.ne
    if
      unreachable
    end
  )
)
</code></pre>
</div>

</div>

<p>We can now run Owi on our program to check if they are the same:</p>
<div class="mdbook-tabs-container" data-tabglobal="lang">
<nav class="mdbook-tabs">
<button class="mdbook-tab active" data-tabname="C">C</button>
<button class="mdbook-tab" data-tabname="C++">C++</button>
<button class="mdbook-tab" data-tabname="Rust">Rust</button>
<button class="mdbook-tab" data-tabname="Zig">Zig</button>
<button class="mdbook-tab" data-tabname="Wasm">Wasm</button>
</nav>
<div class="mdbook-tab-content" data-tabname="C">
<pre><code class="language-sh">$ owi c ./mean.c --entry-point=check --invoke-with-symbols --no-assert-failure-expression-printing
owi: [ERROR] Assert failure
model {
  symbol symbol_0 i32 -1570748002
  symbol symbol_1 i32 -1425538774
}
owi: [ERROR] Reached problem!
[13]
</code></pre>
</div>

<div class="mdbook-tab-content hidden" data-tabname="C++">
<pre><code class="language-sh">$ owi c++ ./mean.cpp --entry-point=check --invoke-with-symbols --no-assert-failure-expression-printing
owi: [ERROR] Assert failure
model {
  symbol symbol_0 i32 -1570748002
  symbol symbol_1 i32 -1425538774
}
owi: [ERROR] Reached problem!
[13]
</code></pre>
</div>

<div class="mdbook-tab-content hidden" data-tabname="Rust">
<pre><code class="language-sh">$ owi rust ./mean.rs --entry-point=check --invoke-with-symbols -w1 --fail-on-assertion-only --no-assert-failure-expression-printing --deterministic-result-order
owi: [ERROR] Assert failure
model {
  symbol symbol_0 i32 915013628
  symbol symbol_1 i32 -1225654275
}

owi: [ERROR] Reached problem!
[13]
</code></pre>
</div>

<div class="mdbook-tab-content hidden" data-tabname="Zig">
<pre><code class="language-sh">$ owi zig ./mean.zig --entry-point=check --invoke-with-symbols -w1 --fail-on-assertion-only --no-assert-failure-expression-printing --deterministic-result-order
owi: [ERROR] Assert failure
model {
  symbol symbol_0 i32 -722535840
  symbol symbol_1 i32 -418314849
}

owi: [ERROR] Reached problem!
[13]
</code></pre>
</div>

<div class="mdbook-tab-content hidden" data-tabname="Wasm">
<pre><code class="language-sh">$ owi sym ./mean.wat --entry-point=check --invoke-with-symbols
owi: [ERROR] Trap: unreachable
model {
  symbol symbol_0 i32 -2147483648
  symbol symbol_1 i32 -2147483646
}
owi: [ERROR] Reached problem!
[13]
</code></pre>
</div>

</div>

<p>And indeed, in the <code>mean1</code> function, when using these values, there will be an overflow, leading to a wrong result.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="examples-of-bug-finding"><a class="header" href="#examples-of-bug-finding">Examples of Bug Finding</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="replaying-a-model"><a class="header" href="#replaying-a-model">Replaying a model</a></h1>
<p>Let‚Äôs say you found a bug and want to check what is going on with the concrete input it contains.
The <code>replay</code> commands can help with that.</p>
<p>First, you need to perform a symbolic run and to store the output model in a file.
Given the following <code>mini.wat</code> file containing symbols:</p>
<!-- $MDX file=mini.wat -->
<pre><code class="language-wat">(module

  (import "owi" "i32_symbol" (func $i32_symbol (result i32)))

  (func $start (local $x i32)
    (local.set $x (call $i32_symbol))

    (if (i32.lt_s (i32.const 5) (local.get $x)) (then
      unreachable
    ))
  )

  (start $start))
</code></pre>
<p>You can get a model like this:</p>
<pre><code class="language-sh">$ owi sym ./mini.wat &gt; mini.scfg
owi: [ERROR] Trap: unreachable
owi: [ERROR] Reached problem!
[13]
</code></pre>
<p>Then you can replay the module execution with the values in the model like this:</p>
<pre><code class="language-sh">$ owi replay --replay-file mini.scfg mini.wat -v
owi: [INFO] parsing      ...
owi: [INFO] checking     ...
owi: [INFO] typechecking ...
owi: [INFO] linking      ...
owi: [INFO] interpreting ...
owi: [INFO] stack         : [  ]
owi: [INFO] running instr : call 1 (executed 0 times)
owi: [INFO] calling func  : func start
owi: [INFO] stack         : [  ]
owi: [INFO] running instr : call 0 (executed 0 times)
owi: [INFO] stack         : [ i32.const 6 ]
owi: [INFO] running instr : local.set 0 (executed 0 times)
owi: [INFO] stack         : [  ]
owi: [INFO] running instr : i32.const 5 (executed 0 times)
owi: [INFO] stack         : [ i32.const 5 ]
owi: [INFO] running instr : local.get 0 (executed 0 times)
owi: [INFO] stack         : [ i32.const 6 ; i32.const 5 ]
owi: [INFO] running instr : i32.lt_s (executed 0 times)
owi: [INFO] stack         : [ i32.const 1 ]
owi: [INFO] running instr : if (executed 0 times)
owi: [INFO] stack         : [  ]
owi: [INFO] running instr : unreachable (executed 0 times)
owi: [ERROR] unreachable
[96]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="comparing-iso-functionnality-of-two-modules"><a class="header" href="#comparing-iso-functionnality-of-two-modules">Comparing iso-functionnality of two modules</a></h1>
<p>The <code>owi iso</code> command takes two Wasm modules as input.
Then, for every common exports between these two modules, Owi will check their equivalence.</p>
<p>Given the following <code>mul1.wat</code> file:</p>
<!-- $MDX file=mul1.wat -->
<pre><code class="language-wat">(module

  (func (export "unused1") (param $x i32)
    local.get $x
    drop
  )

  (func (export "mul") (param $x i32) (param $y i32) (result i32)
    local.get $x
    local.get $y
    i32.mul
  )
)
</code></pre>
<p>And the following <code>mul2.wat</code> file:</p>
<!-- $MDX file=mul2.wat -->
<pre><code class="language-wat">(module

  (func (export "unused2") (param $x i32) (param $y i64) (result i64)
    local.get $x
    (if (then (unreachable)))
    local.get $y
  )

  (func (export "mul") (param $x i32) (param $y i32) (result i32)
    local.get $y
    local.get $x
    i32.mul
    i32.const 1
    i32.add
  )
)
</code></pre>
<p>Owi can find an input for which the <code>mul</code> function of these two modules is not equivalent:</p>
<pre><code class="language-sh">$ owi iso ./mul1.wat ./mul2.wat -v -w1
owi: [INFO] comparing ./mul1.wat and ./mul2.wat
owi: [INFO] module owi_iso_module1 is ./mul1.wat
owi: [INFO] module owi_iso_module2 is ./mul2.wat
owi: [INFO] Compiling ./mul1.wat
owi: [INFO] parsing      ...
owi: [INFO] checking     ...
owi: [INFO] typechecking ...
owi: [INFO] Compiling ./mul2.wat
owi: [INFO] parsing      ...
owi: [INFO] checking     ...
owi: [INFO] typechecking ...
owi: [INFO] common exports: mul
owi: [INFO] checking export mul
owi: [INFO] typechecking ...
owi: [INFO] linking      ...
owi: [INFO] typechecking ...
owi: [INFO] linking      ...
owi: [INFO] typechecking ...
owi: [INFO] linking      ...
owi: [INFO] interpreting ...
owi: [INFO] stack         : [  ]
owi: [INFO] running instr : call 8 (executed 0 times)
owi: [INFO] calling func  : func start
owi: [INFO] stack         : [  ]
owi: [INFO] running instr : call 3 (executed 0 times)
owi: [INFO] stack         : [ symbol_0 ]
owi: [INFO] running instr : call 3 (executed 0 times)
owi: [INFO] stack         : [ symbol_1 ; symbol_0 ]
owi: [INFO] running instr : call 7 (executed 0 times)
owi: [INFO] calling func  : func check_iso_func
owi: [INFO] stack         : [  ]
owi: [INFO] running instr : local.get 0 (executed 0 times)
owi: [INFO] stack         : [ symbol_0 ]
owi: [INFO] running instr : local.get 1 (executed 0 times)
owi: [INFO] stack         : [ symbol_1 ; symbol_0 ]
owi: [INFO] running instr : call 0 (executed 0 times)
owi: [INFO] calling func  : func anonymous
owi: [INFO] stack         : [  ]
owi: [INFO] running instr : local.get 0 (executed 0 times)
owi: [INFO] stack         : [ symbol_0 ]
owi: [INFO] running instr : local.get 1 (executed 0 times)
owi: [INFO] stack         : [ symbol_1 ; symbol_0 ]
owi: [INFO] running instr : i32.mul (executed 0 times)
owi: [INFO] stack         : [ (i32.mul symbol_0 symbol_1) ]
owi: [INFO] running instr : local.get 0 (executed 0 times)
owi: [INFO] stack         : [ symbol_0 ; (i32.mul symbol_0 symbol_1) ]
owi: [INFO] running instr : local.get 1 (executed 0 times)
owi: [INFO] stack         : [ symbol_1 ; symbol_0 ; (i32.mul symbol_0
                                                     symbol_1) ]
owi: [INFO] running instr : call 1 (executed 0 times)
owi: [INFO] calling func  : func anonymous
owi: [INFO] stack         : [  ]
owi: [INFO] running instr : local.get 1 (executed 0 times)
owi: [INFO] stack         : [ symbol_1 ]
owi: [INFO] running instr : local.get 0 (executed 0 times)
owi: [INFO] stack         : [ symbol_0 ; symbol_1 ]
owi: [INFO] running instr : i32.mul (executed 0 times)
owi: [INFO] stack         : [ (i32.mul symbol_1 symbol_0) ]
owi: [INFO] running instr : i32.const 1 (executed 0 times)
owi: [INFO] stack         : [ 1 ; (i32.mul symbol_1 symbol_0) ]
owi: [INFO] running instr : i32.add (executed 0 times)
owi: [INFO] stack         : [ (i32.add (i32.mul symbol_1 symbol_0) 1) ;
            (i32.mul symbol_0 symbol_1) ]
owi: [INFO] running instr : i32.eq (executed 0 times)
owi: [INFO] stack         : [ (i32.of_bool
                               (bool.eq (i32.mul symbol_0 symbol_1)
                                (i32.add (i32.mul symbol_1 symbol_0) 1))) ]
owi: [INFO] running instr : call 2 (executed 0 times)
owi: [ERROR] Assert failure: (bool.eq (i32.mul symbol_0 symbol_1)
                              (i32.add (i32.mul symbol_1 symbol_0) 1))
model {
  symbol symbol_0 i32 0
  symbol symbol_1 i32 0
}
owi: [INFO] Completed paths: 1
owi: [ERROR] Reached problem!
[13]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="bugs-found-by-owi"><a class="header" href="#bugs-found-by-owi">Bugs Found by Owi</a></h1>
<ul>
<li><a href="https://github.com/rust-lang/rust/pull/129321">Wrong neutral element of <code>&lt;fNN as iter::Sum&gt;</code> in the Rust standard library</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="code-coverage-criteria"><a class="header" href="#code-coverage-criteria">Code Coverage Criteria</a></h1>
<p>When we write tests for a codebase, it is common to wonder how good is the test-suite. One way to measure it is through <em>code coverage</em>. That is: how much how the code base is covered by the tests? Most of the time, this notion is not precise. Most tools measuring code coverage can give you a percentage of the coverage, without a clear definition.</p>
<p>Yet there exists some precise definitions for various ways of measuring code coverage. They are called <em>code coverage criteria</em>.</p>
<h2 id="function-coverage"><a class="header" href="#function-coverage">Function Coverage</a></h2>
<p>The easiest one is called <em>function coverage</em> (FC). It measure the percentage of the functions of your programs that are called by the test-suite. For instance, if your whole code base has only two functions, and in your test-suite, only one of them gets execution, then it means you have a function coverage of 50%.</p>
<h2 id="statement-coverage"><a class="header" href="#statement-coverage">Statement Coverage</a></h2>
<p>This criteria (SC) measure the percentage of instructions of your program that are executed.</p>
<h2 id="decision-coverage"><a class="header" href="#decision-coverage">Decision Coverage</a></h2>
<p>This criteria (DC) measure the percentage of decisions covered for you test-suite. For instance, if you have some code looking like the following:</p>
<pre><code class="language-c">void f(int x) {
  if (x) {
    // A
  } else {
    // B
  }
}
</code></pre>
<p>When the conditional is reached, there are two possible decisions. If <code>x</code> is <code>true</code>, then, we execute <code>A</code>. If <code>x</code> is false, then, we execute <code>B</code>.</p>
<h2 id="condition-coverage"><a class="header" href="#condition-coverage">Condition Coverage</a></h2>
<p>This criteria (CC) ‚Ä¶ TODO</p>
<h2 id="todo"><a class="header" href="#todo">TODO</a></h2>
<p>All the others (MC/DC)</p>
<h2 id="todo-explain-that-there-is-a-correspondence-with-the-cfg-covering-nodes-versus-covering-edges-and-such"><a class="header" href="#todo-explain-that-there-is-a-correspondence-with-the-cfg-covering-nodes-versus-covering-edges-and-such">TODO: explain that there is a correspondence with the CFG (covering nodes versus covering edges and such)</a></h2>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="labels"><a class="header" href="#labels">Labels</a></h1>
<p>There exists many code coverage criteria. Having to implement a different mechanism for all of them is tedious. This is a problem solved by <code>labels</code>.</p>
<p>Labels are annotations added to a program (often via an instrumentation pass). Each label correspond to a point that must be reached by the test-suite. The percentage of labels reached by the test-suite is the percentage of code coverage for the criteria that was chosen when adding labels.</p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>For instance, if we are interested in the following program:</p>
<pre><code class="language-c">void f(void) {
  // A
}

void g(void) {
  // B
}
</code></pre>
<p>We could instrument the program to add labels for the FC criteria this way:</p>
<pre><code class="language-c">void f(void) {
  label_reached(0);
  // A
}

void g(void) {
  label_reached(1);
  // B
}
</code></pre>
<p>Then, by providing an appropriate definition of <code>label_reached</code> and knowing how many of them are in the program, we can count how many of them are reached by the test-suite by running it on the instrumented program. Then, we can compute the percentage of code coverage for the FC criteria.</p>
<h2 id="labels-in-owi"><a class="header" href="#labels-in-owi">Labels in Owi</a></h2>
<p>Owi has the ability to :</p>
<ol>
<li>Annotate a Wasm program with labels for a few criteria (see the <code>owi instrument label</code> sub-command).</li>
<li>Generate tests for annotated programs in order to automatically get a high code coverage percentage (run your program with <code>owi sym instrumented.wasm</code>.</li>
</ol>
<p>TODO: complete example with more details on test-case generation</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="e-acsl"><a class="header" href="#e-acsl">E-ACSL</a></h1>
<h1 id="combining-symbolic-execution-with-runtime-assertion-checking-rac"><a class="header" href="#combining-symbolic-execution-with-runtime-assertion-checking-rac">Combining symbolic execution with runtime assertion checking (RAC)</a></h1>
<p>E-ACSL is a specification language of C codes, as well as a runtime assertion checking tool within Frama-C. It works by consuming a C program annotated with E-ACSL specifications, it generates a monitored C program which aborts its execution when the specified properties are violated at runtime.</p>
<p>Generally, such a C program runs on concrete values. Yet we can combine symbolic execution with runtime assertion checking, in order to check the properties using symbolic values. This will lead to better coverage of potential execution paths and scenarios.</p>
<h2 id="finding-primes"><a class="header" href="#finding-primes">Finding primes</a></h2>
<p>Consider the following (faulty) function <code>primes</code>, it implements the algorithm of the <strong>Sieve of Eratosthenes</strong> to find all the prime numbers smaller than <code>n</code>:</p>
<pre><code class="language-c">void primes(int *is_prime, int n) {
    for (int i = 1; i &lt; n; ++i) is_prime[i] = 1;
    for (int i = 2; i * i &lt; n; ++i) {
        if (!is_prime[i]) continue;
        for (int j = i; i * j &lt; n; ++j) {
            is_prime[i * j] = 0;
        }
    }
}
</code></pre>
<p>Initially, it marks each number as prime. It then marks as composite the multiples of each prime, iterating in an ascending order. If a number is still marked as prime at the point of iteration, then it does not admit a nontrivial factor and should be a prime.</p>
<p>In order to verify the implementation, we annotate the function <code>primes</code> using the E-ACSL specification language. The annotations should be written immediately above the function and surrounded by <code>/*@ ... */</code>.</p>
<pre><code class="language-c">#define MAX_SIZE 100

/*@ requires 2 &lt;= n &lt;= MAX_SIZE;
    requires \valid(is_prime + (0 .. (n - 1)));
    ensures  \forall integer i; 0 &lt;= i &lt; n ==&gt;
        (is_prime[i] &lt;==&gt;
            (i &gt;= 2 &amp;&amp; \forall integer j; 2 &lt;= j &lt; i ==&gt; i % j != 0));
*/
void primes(int *is_prime, int n) {
    for (int i = 0; i &lt; n; ++i) is_prime[i] = 1;
    for (int i = 2; i * i &lt; n; ++i) {
        if (!is_prime[i]) continue;
        for (int j = i; i * j &lt; n; ++j) {
            is_prime[i * j] = 0;
        }
    }
}
</code></pre>
<p>Here, <code>requires</code> and <code>ensures</code> specify the pre-condition and post-condition of the function. The annotation means:</p>
<ul>
<li>When the function is called,
<ul>
<li>the argument <code>n</code> should be between <code>2</code> and <code>MAX_SIZE</code></li>
<li>for all <code>i</code> between <code>0</code> and <code>n - 1</code>, <code>is_prime + i</code> should be memory locations safe to read and write</li>
</ul>
</li>
<li>When the function returns,
<ul>
<li>for all <code>i</code> between <code>0</code> and <code>n - 1</code>, <code>is_prime[i]</code> evaluates to <code>true</code> if and only if <code>i</code> is larger than <code>2</code> and does not have a factor between <code>2</code> and <code>i - 1</code> (which indicates the primality of <code>i</code>)</li>
</ul>
</li>
</ul>
<p>We can then call the function with symbolic values and see what happens. We should pass the option <code>--e-acsl</code> to let owi invoke the E-ACSL plugin.</p>
<!-- $MDX file=primes.c -->
<pre><code class="language-c">#define MAX_SIZE 100

#include &lt;owi.h&gt;
#include &lt;stdlib.h&gt;

/*@ requires 2 &lt;= n &lt;= MAX_SIZE;
    requires \valid(is_prime + (0 .. (n - 1)));
    ensures  \forall integer i; 0 &lt;= i &lt; n ==&gt;
        (is_prime[i] &lt;==&gt;
            (i &gt;= 2 &amp;&amp; \forall integer j; 2 &lt;= j &lt; i ==&gt; i % j != 0));
*/
void primes(int *is_prime, int n) {
    for (int i = 0; i &lt; n; ++i) is_prime[i] = 1;
    for (int i = 2; i * i &lt; n; ++i) {
        if (!is_prime[i]) continue;
        for (int j = i; i * j &lt; n; ++j) {
            is_prime[i * j] = 0;
        }
    }
}

int main(void) {
    int *is_prime;
    is_prime = malloc(MAX_SIZE * sizeof(int));

    int n = owi_int();
    owi_assume(n &gt;= 2);
    owi_assume(n &lt;= MAX_SIZE);

    primes(is_prime, n);
    free(is_prime);
    return 0;
}
</code></pre>
<pre><code class="language-sh">$ owi c --e-acsl primes.c -w1
owi: [ERROR] Assert failure: false
model {
  symbol symbol_0 i32 2
}
owi: [ERROR] Reached problem!
[13]
</code></pre>
<p>The execution got aborted because one of the specifications has been violated with <code>n = 2</code>. (The error message is not so informative for the time being, extra information aiding the diagnostic of errors may be added in the future.)</p>
<p>The problem is that we should mark <code>0</code> and <code>1</code> as non-prime during the initialization. Let‚Äôs fix it and rerun the program.</p>
<!-- $MDX file=primes2.c -->
<pre><code class="language-c">#define MAX_SIZE 100

#include &lt;owi.h&gt;
#include &lt;stdlib.h&gt;

/*@ requires 2 &lt;= n &lt;= MAX_SIZE;
    requires \valid(is_prime + (0 .. (n - 1)));
    ensures  \forall integer i; 0 &lt;= i &lt; n ==&gt;
        (is_prime[i] &lt;==&gt;
            (i &gt;= 2 &amp;&amp; \forall integer j; 2 &lt;= j &lt; i ==&gt; i % j != 0));
*/
void primes(int *is_prime, int n) {
    for (int i = 0; i &lt; n; ++i) is_prime[i] = 1;
    is_prime[0] = is_prime[1] = 0;
    for (int i = 2; i * i &lt; n; ++i) {
        if (!is_prime[i]) continue;
        for (int j = i; i * j &lt; n; ++j) {
            is_prime[i * j] = 0;
        }
    }
}

int main(void) {
    int *is_prime;
    is_prime = malloc(MAX_SIZE * sizeof(int));

    int n = owi_int();
    owi_assume(n &gt;= 2);
    owi_assume(n &lt;= MAX_SIZE);

    primes(is_prime, n);
    free(is_prime);
    return 0;
}
</code></pre>
<pre><code class="language-sh">$ # owi c --e-acsl primes2.c -w1
</code></pre>
<p>All the specified properties have been satisfied during the execution.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="examples-of-problem-solving"><a class="header" href="#examples-of-problem-solving">Examples of Problem Solving</a></h1>
<h2 id="solving-polynomials"><a class="header" href="#solving-polynomials">Solving polynomials</a></h2>
<details>
  <summary>C</summary>
<p>Given the following <code>poly.c</code> file:</p>
<!-- $MDX file=poly.c -->
<pre><code class="language-c">#include &lt;owi.h&gt;

int main() {
  int x = owi_int();
  int x2 = x * x;
  int x3 = x * x * x;

  int a = 1;
  int b = -7;
  int c = 14;
  int d = -8;

  int poly = a * x3 + b * x2 + c * x + d;

  owi_assert(poly != 0);

  return 0;
}
</code></pre>
<p>We are defining one symbolic variable <code>x</code> using the function <code>owi_i32(void)</code>. Then we build a polynomial <code>poly</code> equal to $x^3 - 7x^2 + 14x - 8$.</p>
<p>Then we use <code>owi_assert(poly != 0)</code>. Which should fail as this polynomial has multiple roots. Let‚Äôs see what owi says about it:</p>
<pre><code class="language-sh">$ owi c ./poly.c -w1 --no-assert-failure-expression-printing
owi: [ERROR] Assert failure
model {
  symbol symbol_0 i32 4
}
owi: [ERROR] Reached problem!
[13]
</code></pre>
<p>Indeed, <code>4</code> is a root of the polynomial and thus it is expected to be equal to <code>0</code> in this case. We know the three roots are <code>1</code>, <code>2</code> and <code>4</code>, so let‚Äôs inform owi that we are not interested in this cases.</p>
<p>We can do so by assuming that <code>x</code> is not equal to any of these with the function <code>owi_assume(bool)</code>:</p>
<!-- $MDX file=poly2.c -->
<pre><code class="language-c">#include &lt;owi.h&gt;

int main() {
  int x = owi_int();
  int x2 = x * x;
  int x3 = x * x * x;

  int a = 1;
  int b = -7;
  int c = 14;
  int d = -8;

  int poly = a * x3 + b * x2 + c * x + d;

  owi_assume(x != 1);
  owi_assume(x != 2);
  owi_assume(x != 4);

  // Make model output deterministic
  owi_assume(x &gt; -2147483646);

  owi_assert(poly != 0);

  return 0;
}
</code></pre>
<p>Let‚Äôs run owi on this new input:</p>
<pre><code class="language-sh">$ owi c ./poly2.c --no-assert-failure-expression-printing
owi: [ERROR] Assert failure
model {
  symbol symbol_0 i32 -2147483644
}
owi: [ERROR] Reached problem!
[13]
</code></pre>
<p>And indeed, <code>-2147483644</code> is a root of the polynomial! Well, not quite‚Ä¶</p>
<p>Remember that we are working on 32 bits integers here. Thus <em>overflows</em> are a thing we have to think about. And indeed when <code>x</code> is equal to <code>-2147483644</code>, because of overflows, the polynomial will be equal to zero.</p>
<p>Exercise: can you find another ‚Äúroot‚Äù of the polynomial ? :-)</p>
</details>
<details>
  <summary>C++</summary>
<p>Given the following <code>poly.cpp</code> file:</p>
<!-- $MDX file=poly.cpp -->
<pre><code class="language-cpp">#include &lt;owi.h&gt;

class Poly {
private:
  int poly;
public:
  Poly(int a, int b, int c, int d) {
    int x = owi_int();
    int x2 = x * x;
    int x3 = x2 * x;
    poly = a*x3 + b*x2 + c*x + d;
  }

  int hasRoot() const { return poly == 0; }
};

int main() {
  Poly p(1, -7, 14, -8);
  owi_assert(not(p.hasRoot()));
}
</code></pre>
<p>We are defining one symbolic variable <code>x</code> using the function <code>owi_i32(void)</code>. Then we build a polynomial <code>poly</code> equal to $x^3 - 7x^2 + 14x - 8$.</p>
<p>Then we use <code>owi_assert(p.getPoly() != 0)</code>. Which should fail as this polynomial has multiple roots. Let‚Äôs see what owi says about it:</p>
<pre><code class="language-sh">$ owi c++ ./poly.cpp -w1 --no-assert-failure-expression-printing
owi: [ERROR] Assert failure
model {
  symbol symbol_0 i32 2
}
owi: [ERROR] Reached problem!
[13]
</code></pre>
<p>Indeed, <code>4</code> is a root of the polynomial and thus it is expected to be equal to <code>0</code> in this case. We know the three roots are <code>1</code>, <code>2</code> and <code>4</code>, so let‚Äôs inform owi that we are not interested in this cases.</p>
<p>We can do so by assuming that <code>x</code> is not equal to any of these with the function <code>owi_assume(bool)</code>:</p>
<!-- $MDX file=poly2.cpp -->
<pre><code class="language-cpp">#include &lt;owi.h&gt;

class Poly {
private:
  int poly;
public:
  Poly(int a, int b, int c, int d) {
    int x = owi_int();
    int x2 = x * x;
    int x3 = x2 * x;
    owi_assume(x != 1);
    owi_assume(x != 2);
    // make model output deterministic
    owi_assume(x &gt; -2147483646);
    owi_assume(x != 4);
    poly = a*x3 + b*x2 + c*x + d;
  }

  int hasRoot() const { return poly == 0; }
};

int main() {
  Poly p(1, -7, 14, -8);
  owi_assert(not(p.hasRoot()));
}
</code></pre>
<p>Let‚Äôs run owi on this new input:</p>
<pre><code class="language-sh">$ owi c++ ./poly2.cpp --no-assert-failure-expression-printing
owi: [ERROR] Assert failure
model {
  symbol symbol_0 i32 -2147483644
}
owi: [ERROR] Reached problem!
[13]
</code></pre>
<p>And indeed, <code>-2147483644</code> is a root of the polynomial! Well, not quite‚Ä¶</p>
<p>Remember that we are working on 32 bits integers here. Thus <em>overflows</em> are a thing we have to think about. And indeed when <code>x</code> is equal to <code>-2147483644</code>, because of overflows, the polynomial will be equal to zero.</p>
<p>Exercise: can you find another ‚Äúroot‚Äù of the polynomial ? :-)</p>
</details>
<h2 id="solving-a-maze"><a class="header" href="#solving-a-maze">Solving a maze</a></h2>
<!-- $MDX file=maze.c -->
<pre><code class="language-c">#include &lt;owi.h&gt;

// example from https://feliam.wordpress.com/2010/10/07/the-symbolic-maze/

#define H 7
#define W 11
#define ITERS 28

char maze[H][W] = {
  "+-+---+---+",
  "| |     |#|",
  "| | --+ | |",
  "| |   | | |",
  "| +-- | | |",
  "|     |   |",
  "+-----+---+"
};

int main (void) {

  int x = 1;
  int y = 1;
  maze[y][x]='X';

  char program[ITERS];

  for (int i = 0; i &lt; ITERS; i++) {
    program[i] = owi_char();
  }

  int old_x = x;
  int old_y = y;

  for (int i = 0; i &lt; ITERS; i++) {

    old_x = x;
    old_y = y;

    switch (program[i]) {
      case 'w':
        y--;
        break;
      case 's':
        y++;
        break;
      case 'a':
        x--;
        break;
      case 'd':
        x++;
        break;
      default:
        return 1;
    }

    if (maze[y][x] == '#') {
      // TODO: print the result
      owi_assert(0);
      return 0;
    }

    if (maze[y][x] != ' ' &amp;&amp; !((y == 2 &amp;&amp; maze[y][x] == '|' &amp;&amp; x &gt; 0 &amp;&amp; x &lt; W))) {
      return 1;
    }

    if (old_x == x &amp;&amp; old_y == y) {
      return 1;
    }

    maze[y][x] = 'X';
  }
  return 1;
}
</code></pre>
<pre><code class="language-sh">$ owi c ./maze.c --no-value --no-assert-failure-expression-printing
owi: [ERROR] Assert failure
model {
  symbol symbol_0 i32
  symbol symbol_1 i32
  symbol symbol_2 i32
  symbol symbol_3 i32
  symbol symbol_4 i32
  symbol symbol_5 i32
  symbol symbol_6 i32
  symbol symbol_7 i32
  symbol symbol_8 i32
  symbol symbol_9 i32
  symbol symbol_10 i32
  symbol symbol_11 i32
  symbol symbol_12 i32
  symbol symbol_13 i32
  symbol symbol_14 i32
  symbol symbol_15 i32
  symbol symbol_16 i32
  symbol symbol_17 i32
  symbol symbol_18 i32
  symbol symbol_19 i32
  symbol symbol_20 i32
  symbol symbol_21 i32
  symbol symbol_22 i32
  symbol symbol_23 i32
  symbol symbol_24 i32
  symbol symbol_25 i32
  symbol symbol_26 i32
  symbol symbol_27 i32
}
owi: [ERROR] Reached problem!
[13]
</code></pre>
<h2 id="dobble-example"><a class="header" href="#dobble-example">Dobble example</a></h2>
<!-- $MDX file=dobble.c -->
<pre><code class="language-c">// An encoding representing the problem of finding a suitable
// set of cards for https://en.wikipedia.org/wiki/Dobble.
// Cards are encoded on integers, with each position
// representing one of N_CARDS possible symbols.
#include &lt;owi.h&gt;
#include &lt;stdlib.h&gt;

// Number of symbols per card
#define CARD_SIZE 3

#define N_CARDS ((CARD_SIZE*CARD_SIZE) - CARD_SIZE + 1)

int popcount(unsigned int x) {
    int count = 0;
    for (int i = 0; i &lt; N_CARDS; i++) {
        count += x &amp; 1;
        x &gt;&gt;= 1;
    }
    return count;
}

int main() {
    unsigned int cards[N_CARDS];
    for (int i=0;i &lt; N_CARDS; i++) {
        unsigned int x = owi_unsigned_int();
        owi_assume((x &gt;&gt; N_CARDS) == 0);
        owi_assume(popcount(x) == CARD_SIZE);
        cards[i] = x;
        if (i &gt; 0) {
            owi_assume(cards[i] &gt; cards[i-1]);
        }
    }
    unsigned int acc = 1;
    for (int i=0;i &lt; N_CARDS; i++) {
        for(int j=i+1; j &lt; N_CARDS;j++) {
            owi_assume(cards[i] != cards[j]);
            unsigned int z = cards[i] &amp; cards[j];
            acc = acc &amp; (z != 0);
            acc = acc &amp; ((z &amp; (z-1)) == 0);
        }
    }
    owi_assert(!acc);
}
</code></pre>
<!-- TODO: remove `-O1` once symbolic popcnt is implemented -->
<pre><code class="language-sh">$ owi c -O1 ./dobble.c -w1 --no-value --no-assert-failure-expression-printing
owi: [ERROR] Assert failure
model {
  symbol symbol_0 i32
  symbol symbol_1 i32
  symbol symbol_2 i32
  symbol symbol_3 i32
  symbol symbol_4 i32
  symbol symbol_5 i32
  symbol symbol_6 i32
}
owi: [ERROR] Reached problem!
[13]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="how-to-speed-it-up"><a class="header" href="#how-to-speed-it-up">How to Speed it Up</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="comparison-to-rosette-prolog-etc"><a class="header" href="#comparison-to-rosette-prolog-etc">Comparison to Rosette, Prolog, etc.</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="talks-and-papers"><a class="header" href="#talks-and-papers">Talks and Papers</a></h1>
<h2 id="publications"><a class="header" href="#publications">Publications</a></h2>
<ul>
<li><a href="https://hal.science/hal-04627413">Owi: Performant Parallel Symbolic Execution Made Easy, an Application to WebAssembly</a>, 2024</li>
<li><a href="https://fs.zapashcanon.fr/pdf/manuscrit_these_leo_andres.pdf">Ex√©cution symbolique pour tous ou Compilation d‚ÄôOCaml vers WebAssembly</a>, 2024</li>
<li><a href="https://inria.hal.science/hal-04798756/file/cross_language_symbolic_runtime_annotation_checking.pdf">Cross-Language Symbolic Runtime Annotation Checking</a>, 2025</li>
</ul>
<h2 id="talks"><a class="header" href="#talks">Talks</a></h2>
<ul>
<li><a href="https://youtu.be/IM76cMP3Eqo">september 2023</a>: <a href="https://icfp23.sigplan.org/home/ocaml-2023">ICFP OCaml track</a> @ The Westin Seattle - Seattle</li>
<li><a href="https://youtu.be/os_pknmiqmU">october 2023</a>: Wasm Research Day organized by the <a href="https://www.cs.cmu.edu/wrc">WebAssembly Research Center</a> @ Google - Munich</li>
<li>april 2024: <a href="https://oups.frama.io">OUPS (OCaml UserS in Paris)</a> @ Sorbonne Universit√© - Paris</li>
<li><a href="https://groupes.renater.fr/wiki/lvp/public/journee_lvp_novembre2024">november 2024</a>: <a href="https://gdrgpl.myxwiki.org/xwiki/bin/view/Main/GTs/GT%20Langages%20et%20v%C3%A9rification%20de%20programmes%20(LVP)">LVP working group</a> day of the <a href="https://gdr-gpl.cnrs.fr/">GdR GPL</a> @ Universit√© Paris-Cit√© - Paris</li>
<li><a href="https://fs.zapashcanon.fr/mp4/phd_defense.mp4">december 2024</a>: L√©o Andr√®s‚Äô PhD defense @ Universit√© Paris-Saclay - Gif-sur-Yvette</li>
<li>january 2025: <a href="https://jfla.inria.fr/jfla2025.html">JFLA 2025</a> @ Domaine de Roiff√© - Roiff√©</li>
<li><a href="https://youtu.be/x6V-NJ9agjg">february 2025</a>: <a href="https://www.cs.cmu.edu/~wasm/wasm-research-day-2025.html">Wasm Research Day 2025</a> (remote) @ Fastly - San Francisco</li>
<li>february 2025: <a href="https://www.irif.fr/seminaires/pps/index">PPS Seminar</a> @ Universit√© Paris-Cit√© - Paris</li>
<li>may 2025: <a href="https://retreat.mirage.io">15th MirageOS hack retreat</a> @ Priscilla Queen of the Medina - Marrakech</li>
<li>june 2025: <a href="https://2025.programming-conference.org">&lt;Programming&gt; 2025</a> @ Faculty of Mathematics and Physics, Charles University - Prague</li>
<li>june 2025: <a href="https://www.dagstuhl.de/seminars/seminar-calendar/seminar-details/25241">Dagstuhl Seminar 25241 - Utilising and Scaling the WebAssembly Semantics</a> @ Leibniz-Zentrum f√ºr Informatik - Dagstuhl</li>
<li>october 2025: <a href="https://www.cs.cmu.edu/~wasm/wasm-research-day-2025b.html">Wasm Research Day October 2025</a> @ Google - Munich</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="commands-and-options"><a class="header" href="#commands-and-options">Commands and Options</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="api-symbols-and-helpers"><a class="header" href="#api-symbols-and-helpers">API: Symbols and Helpers</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<h2 id="formatter"><a class="header" href="#formatter">Formatter</a></h2>
<p>Given a file <code>horrible.wat</code>:</p>
<details>
<!-- $MDX file=horrible.wat -->
<pre><code class="language-wat">(module (memory
10) (func
$f (param
     $n i32) (result
i32) (if
             (                       i32.lt_s
        (
local.get $n)
        (
                          i32.const
                          
                          
                          0))
    (  then
(
 
 unreachable)))

    (
     if
( 
i32.lt_s
        (local.get                            $n)
        (i32.const                             2))
    (then          (return (local.get $n)))) (if   
      (i32.eqz   
(i32.load (i32.mul (i32.const 4) (local.get $n)))) (then local.get $n i32.const 4 i32.mul
      (call $f (i32.sub (local.get $n) (i32.const 1)))
      (call $f (i32.sub (local.get $n)
(i32.const 2))) i32.add   i32.store )) local.get $n       i32.const 4 i32.mul i32.load return))
</code></pre>
</details>
<p>Owi will format it like this:</p>
<pre><code class="language-sh">$ owi fmt horrible.wat
(module
  (memory 10)
  (func $f (param $n i32) (result i32)
    local.get $n
    i32.const 0
    i32.lt_s
    (if
      (then
        unreachable
      )
    )
    local.get $n
    i32.const 2
    i32.lt_s
    (if
      (then
        local.get $n
        return
      )
    )
    i32.const 4
    local.get $n
    i32.mul
    i32.load
    i32.eqz
    (if
      (then
        local.get $n
        i32.const 4
        i32.mul
        local.get $n
        i32.const 1
        i32.sub
        call $f
        local.get $n
        i32.const 2
        i32.sub
        call $f
        i32.add
        i32.store
      )
    )
    local.get $n
    i32.const 4
    i32.mul
    i32.load
    return
  )
)
</code></pre>
<p>Are you able to recognize the program now?</p>
<h2 id="interpreter"><a class="header" href="#interpreter">Interpreter</a></h2>
<p>Given a file <code>42.wat</code> with the following content:</p>
<!-- $MDX file=42.wat -->
<pre><code class="language-wat">(module $quickstart
  (func $f
    i32.const 20
    i32.const 22
    i32.add
    drop
  )
  (start $f)
)
</code></pre>
<p>Running the interpreter is as simple as:</p>
<pre><code class="language-sh">$ owi run ./42.wat
</code></pre>
<p>Nothing is happening, so you can add the <code>-v</code> option to print an execution trace:</p>
<pre><code class="language-sh">$ owi run ./42.wat -v
owi: [INFO] parsing      ...
owi: [INFO] checking     ...
owi: [INFO] typechecking ...
owi: [INFO] linking      ...
owi: [INFO] interpreting ...
owi: [INFO] stack         : [  ]
owi: [INFO] running instr : call 0 (executed 0 times)
owi: [INFO] calling func  : func f
owi: [INFO] stack         : [  ]
owi: [INFO] running instr : i32.const 20 (executed 0 times)
owi: [INFO] stack         : [ i32.const 20 ]
owi: [INFO] running instr : i32.const 22 (executed 0 times)
owi: [INFO] stack         : [ i32.const 22 ; i32.const 20 ]
owi: [INFO] running instr : i32.add (executed 0 times)
owi: [INFO] stack         : [ i32.const 42 ]
owi: [INFO] running instr : drop (executed 0 times)
</code></pre>
<h2 id="script-using-the-spectest-module"><a class="header" href="#script-using-the-spectest-module">Script using the <code>spectest</code> module</a></h2>
<p>Given the following <code>print.wast</code> file:</p>
<!-- $MDX file=print.wast -->
<pre><code class="language-wast">(module

  (func $print_i32 (import "spectest" "print_i32") (param i32))

  (func $main
    i32.const 42
    call $print_i32
  )

  (start $main)
)
</code></pre>
<p>You can print the value thanks to the <code>print_i32</code> function imported from the <code>spectest</code> module:</p>
<pre><code class="language-sh">$ owi script ./print.wast
42
</code></pre>
<h2 id="validator"><a class="header" href="#validator">Validator</a></h2>
<p>Given a file <code>type_error.wat</code> with the following content:</p>
<!-- $MDX file=type_error.wat -->
<pre><code class="language-wat">(module $quickstart
  (func $f
    i32.const 20
    i32.const 22
    i32.add
    i32.add
    drop
  )
  (start $f)
)
</code></pre>
<p>Running the validator is as simple as:</p>
<pre><code class="language-sh">$ owi validate ./type_error.wat
owi: [ERROR] type mismatch (expected [i32 i32] but stack is [i32])
[35]
</code></pre>
<p>You can also print a more detailed trace with the <code>-v</code> option:</p>
<pre><code class="language-sh">$ owi validate ./type_error.wat -v
owi: [INFO] parsing      ...
owi: [INFO] checking     ...
owi: [INFO] typechecking ...
owi: [ERROR] type mismatch (expected [i32 i32] but stack is [i32])
[35]
</code></pre>
<h2 id="wasm2wat"><a class="header" href="#wasm2wat">Wasm2wat</a></h2>
<p>Given a file <code>42.wasm</code>, you can convert it to <code>result.wat</code> and then run it:</p>
<pre><code class="language-sh">$ owi wasm2wat 42.wasm -o result.wat
$ cat result.wat
(module
  (type (func))
  (func
    i32.const 20
    i32.const 22
    i32.add
    drop
  )
  (start 0)
)
$ owi run result.wat -v
owi: [INFO] parsing      ...
owi: [INFO] checking     ...
owi: [INFO] typechecking ...
owi: [INFO] linking      ...
owi: [INFO] interpreting ...
owi: [INFO] stack         : [  ]
owi: [INFO] running instr : call 0 (executed 0 times)
owi: [INFO] calling func  : func anonymous
owi: [INFO] stack         : [  ]
owi: [INFO] running instr : i32.const 20 (executed 0 times)
owi: [INFO] stack         : [ i32.const 20 ]
owi: [INFO] running instr : i32.const 22 (executed 0 times)
owi: [INFO] stack         : [ i32.const 22 ; i32.const 20 ]
owi: [INFO] running instr : i32.add (executed 0 times)
owi: [INFO] stack         : [ i32.const 42 ]
owi: [INFO] running instr : drop (executed 0 times)
</code></pre>
<h2 id="wat2wasm"><a class="header" href="#wat2wasm">Wat2wasm</a></h2>
<p>Given a file <code>42.wat</code>, you can convert it to <code>result.wasm</code> and then run it:</p>
<pre><code class="language-sh">$ owi wat2wasm 42.wat -o result.wasm
$ owi run result.wasm -v
owi: [INFO] typechecking ...
owi: [INFO] linking      ...
owi: [INFO] interpreting ...
owi: [INFO] stack         : [  ]
owi: [INFO] running instr : call 0 (executed 0 times)
owi: [INFO] calling func  : func anonymous
owi: [INFO] stack         : [  ]
owi: [INFO] running instr : i32.const 20 (executed 0 times)
owi: [INFO] stack         : [ i32.const 20 ]
owi: [INFO] running instr : i32.const 22 (executed 0 times)
owi: [INFO] stack         : [ i32.const 22 ; i32.const 20 ]
owi: [INFO] running instr : i32.add (executed 0 times)
owi: [INFO] stack         : [ i32.const 42 ]
owi: [INFO] running instr : drop (executed 0 times)
</code></pre>
<h2 id="call-graph"><a class="header" href="#call-graph">Call Graph</a></h2>
<p>Given a file <code>useless.wat</code> with the following content:</p>
<pre><code class="language-wat">(module

  (func $start
    i32.const 0
    (if
    (then call $a)
    (else call $b)
    )
  )

  (func $a 
  (block
  call $b)
  call $c)

  (func $b)

  (func $c)

  (start $start))
</code></pre>
<p>You can then create a file <code>useless.dot</code> containing the call graph of the programm:</p>
<pre><code class="language-sh">$ owi analyze cg useless.wat
</code></pre>
<p><img src="wasm-toolkit/call_graph.svg" alt="image"></p>
<h2 id="control-flow-graph"><a class="header" href="#control-flow-graph">Control-Flow Graph</a></h2>
<p>Given a file <code>useless.wat</code> with the following content:</p>
<pre><code class="language-wat">(module
    (func $foo (param i32) (result i32)
       (local i32)
       (block
           (block
               (block
                   local.get 0
                   i32.eqz
                   br_if 0

                   local.get 0
                   i32.const 1
                   i32.eq
                   br_if 1

                   i32.const 7
                   local.set 1
                   br 2)
             i32.const 42
             local.set 1
             br 1)
         i32.const 99
         local.set 1)
       local.get 1)
)
</code></pre>
<p>You can then create a file <code>useless.dot</code> containing the control flow graph of the function foo:</p>
<pre><code class="language-sh">$ owi analyze cfg useless.wat --entry-point=foo
</code></pre>
<p><img src="wasm-toolkit/control-flow_graph.svg" alt="image"></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="comparison-with-other-tools-1"><a class="header" href="#comparison-with-other-tools-1">Comparison with Other Tools</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="owi"><a class="header" href="#owi"><code>owi</code></a></h1>
<pre><code class="language-sh">$ owi --help=plain
NAME
       owi - OCaml WebAssembly Interpreter

SYNOPSIS
       owi [COMMAND] ‚Ä¶

COMMANDS
       analyze COMMAND ‚Ä¶
           Analyze a program in different possible ways

       c [OPTION]‚Ä¶ FILE‚Ä¶
           Compile a C file to Wasm and run the symbolic interpreter on it

       c++ [OPTION]‚Ä¶ FILE‚Ä¶
           Compile a C++ file to Wasm and run the symbolic interpreter on it

       fmt [--inplace] [OPTION]‚Ä¶ FILE‚Ä¶
           Format a .wat or .wast file

       instrument COMMAND ‚Ä¶
           Instrument a program in various ways

       iso [OPTION]‚Ä¶ FILE‚Ä¶
           Check the iso-functionnality of two Wasm modules by comparing the
           output when calling their exports.

       replay [OPTION]‚Ä¶ FILE
           Replay a module containing symbols with concrete values in a
           replay file containing a model

       run [--timeout=S] [--timeout-instr=I] [--unsafe] [OPTION]‚Ä¶ FILE
           Run the concrete interpreter

       rust [OPTION]‚Ä¶ FILE‚Ä¶
           Compile a Rust file to Wasm and run the symbolic interpreter on it

       script [--no-exhaustion] [OPTION]‚Ä¶ FILE‚Ä¶
           Run a reference test suite script

       sym [OPTION]‚Ä¶ FILE
           Run the symbolic interpreter

       tinygo [OPTION]‚Ä¶ FILE‚Ä¶
           Compile a TinyGo file to Wasm and run the symbolic interpreter on
           it

       validate [OPTION]‚Ä¶ FILE‚Ä¶
           Validate a module

       version [OPTION]‚Ä¶
           Print some version informations

       wasm2wat [--emit-file] [--output=FILE] [OPTION]‚Ä¶ FILE
           Generate a text format file (.wat) from a binary format file
           (.wasm)

       wat2wasm [--output=FILE] [--unsafe] [OPTION]‚Ä¶ FILE
           Generate a binary format file (.wasm) from a text format file
           (.wat)

       zig [OPTION]‚Ä¶ FILE‚Ä¶
           Compile a Zig file to Wasm and run the symbolic interpreter on it

COMMON OPTIONS
       --help[=FMT] (default=auto)
           Show this help in format FMT. The value FMT must be one of auto,
           pager, groff or plain. With auto, the format is pager or plain
           whenever the TERM env var is dumb or undefined.

       --version
           Show version information.

EXIT STATUS
       owi exits with:

       0   on success.

       123 on indiscriminate errors reported on standard error.

       124 on command line parsing errors.

       125 on unexpected internal errors (bugs).

BUGS
       Email them to &lt;contact@ndrs.fr&gt;.

</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="owi-analyze"><a class="header" href="#owi-analyze"><code>owi analyze</code></a></h1>
<pre><code class="language-sh">$ owi analyze --help=plain
NAME
       owi-analyze - Analyze a program in different possible ways

SYNOPSIS
       owi analyze COMMAND ‚Ä¶

COMMANDS
       cfg [--entry-point=FUNCTION] [OPTION]‚Ä¶ FILE
           Build a Control-Flow Graph

       cg [--call-graph-mode=VAL] [--entry-point=FUNCTION] [OPTION]‚Ä¶ FILE
           Build a call graph

COMMON OPTIONS
       --help[=FMT] (default=auto)
           Show this help in format FMT. The value FMT must be one of auto,
           pager, groff or plain. With auto, the format is pager or plain
           whenever the TERM env var is dumb or undefined.

       --version
           Show version information.

EXIT STATUS
       owi analyze exits with:

       0   on success.

       123 on indiscriminate errors reported on standard error.

       124 on command line parsing errors.

       125 on unexpected internal errors (bugs).

BUGS
       Email them to &lt;contact@ndrs.fr&gt;.

SEE ALSO
       owi(1)

</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="owi-c"><a class="header" href="#owi-c"><code>owi c</code></a></h1>
<pre><code class="language-sh">$ owi c --help=plain
NAME
       owi-c - Compile a C file to Wasm and run the symbolic interpreter on
       it

SYNOPSIS
       owi c [OPTION]‚Ä¶ FILE‚Ä¶

ARGUMENTS
       FILE (required)
           source files

OPTIONS
       --deterministic-result-order
           Guarantee a fixed deterministic order of found failures. This
           implies --no-stop-at-failure.

       --e-acsl
           e-acsl mode, refer to
           https://frama-c.com/download/e-acsl/e-acsl-implementation.pdf for
           Frama-C's current language feature implementations

       --entry-point=FUNCTION (absent=main)
           entry point of the executable

       --exploration=VAL (absent=fifo)
           exploration strategy to use ("fifo", "lifo", "random",
           "random-unseen-then-random", "rarity", "hot-path-penalty",
           "rarity-aging", "rarity-depth-aging", "rarity-depth-loop-aging",
           "rarity-depth-loop-aging-random")

       --fail-on-assertion-only
           ignore traps and only report assertion violations

       --fail-on-trap-only
           ignore assertion violations and only report traps

       -I VAL
           headers path

       --invoke-with-symbols
           Invoke the entry point of the program with symbolic values instead
           of dummy constants.

       -m VAL, --arch=VAL (absent=32)
           data model

       --model-format=VAL (absent=scfg)
            The format of the model ("json" or "scfg")

       --model-out-file=FILE
           Output the generated model to FILE. if --no-stop-at-failure is
           given this is used as a prefix and the ouputed files would have
           PREFIX_%d.

       --no-assert-failure-expression-printing
           do not display the expression in the assert failure

       --no-ite-for-select
           do not use ite for select

       --no-stop-at-failure
           do not stop when a program failure is encountered

       --no-value
           do not display a value for each symbol

       --no-worker-isolation
           Do not force each worker to run on an isolated physical core.

       -o FILE, --output=FILE
           Output the generated .wasm or .wat to FILE.

       -O VAL (absent=3)
           specify which optimization level to use

       --property=FILE
           property file

       -s VALUE, --solver=VALUE (absent=Z3)
           SMT solver to use. VALUE must be one of the 5 available solvers:
           Z3, Bitwuzla, Colibri2, cvc5, Alt-Ergo

       --testcomp
           test-comp mode

       -u, --unsafe
           skip typechecking pass

       -w VAL, --workers=VAL (absent=n)
           Number of workers for symbolic execution. Defaults to the number
           of physical cores.

       --with-breadcrumbs
           add breadcrumbs to the generated model

       --workspace=DIR
           write results and intermediate compilation artifacts to dir

COMMON OPTIONS
       --bench
           enable benchmarks

       --color=WHEN (absent=auto)
           Colorize the output. WHEN must be one of auto, always or never.

       --help[=FMT] (default=auto)
           Show this help in format FMT. The value FMT must be one of auto,
           pager, groff or plain. With auto, the format is pager or plain
           whenever the TERM env var is dumb or undefined.

       -q, --quiet
           Be quiet. Takes over -v and --verbosity.

       -v, --verbose
           Increase verbosity. Repeatable, but more than twice does not bring
           more.

       --verbosity=LEVEL (absent=warning or OWI_VERBOSITY env)
           Be more or less verbose. LEVEL must be one of quiet, error,
           warning, info or debug. Takes over -v.

       --version
           Show version information.

EXIT STATUS
       owi c exits with:

       0   on success.

       123 on indiscriminate errors reported on standard error.

       124 on command line parsing errors.

       125 on unexpected internal errors (bugs).

ENVIRONMENT
       These environment variables affect the execution of owi c:

       OWI_VERBOSITY
           See option --verbosity.

BUGS
       Email them to &lt;contact@ndrs.fr&gt;.

SEE ALSO
       owi(1)

</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="owi-c-1"><a class="header" href="#owi-c-1"><code>owi c++</code></a></h1>
<pre><code class="language-sh">$ owi c++ --help=plain
NAME
       owi-c++ - Compile a C++ file to Wasm and run the symbolic interpreter
       on it

SYNOPSIS
       owi c++ [OPTION]‚Ä¶ FILE‚Ä¶

ARGUMENTS
       FILE (required)
           source files

OPTIONS
       --deterministic-result-order
           Guarantee a fixed deterministic order of found failures. This
           implies --no-stop-at-failure.

       --entry-point=FUNCTION (absent=main)
           entry point of the executable

       --exploration=VAL (absent=fifo)
           exploration strategy to use ("fifo", "lifo", "random",
           "random-unseen-then-random", "rarity", "hot-path-penalty",
           "rarity-aging", "rarity-depth-aging", "rarity-depth-loop-aging",
           "rarity-depth-loop-aging-random")

       --fail-on-assertion-only
           ignore traps and only report assertion violations

       --fail-on-trap-only
           ignore assertion violations and only report traps

       -I VAL
           headers path

       --invoke-with-symbols
           Invoke the entry point of the program with symbolic values instead
           of dummy constants.

       -m VAL, --arch=VAL (absent=32)
           data model

       --model-format=VAL (absent=scfg)
            The format of the model ("json" or "scfg")

       --model-out-file=FILE
           Output the generated model to FILE. if --no-stop-at-failure is
           given this is used as a prefix and the ouputed files would have
           PREFIX_%d.

       --no-assert-failure-expression-printing
           do not display the expression in the assert failure

       --no-ite-for-select
           do not use ite for select

       --no-stop-at-failure
           do not stop when a program failure is encountered

       --no-value
           do not display a value for each symbol

       --no-worker-isolation
           Do not force each worker to run on an isolated physical core.

       -o FILE, --output=FILE
           Output the generated .wasm or .wat to FILE.

       -O VAL (absent=3)
           specify which optimization level to use

       -s VALUE, --solver=VALUE (absent=Z3)
           SMT solver to use. VALUE must be one of the 5 available solvers:
           Z3, Bitwuzla, Colibri2, cvc5, Alt-Ergo

       -u, --unsafe
           skip typechecking pass

       -w VAL, --workers=VAL (absent=n)
           Number of workers for symbolic execution. Defaults to the number
           of physical cores.

       --with-breadcrumbs
           add breadcrumbs to the generated model

       --workspace=DIR
           write results and intermediate compilation artifacts to dir

COMMON OPTIONS
       --bench
           enable benchmarks

       --color=WHEN (absent=auto)
           Colorize the output. WHEN must be one of auto, always or never.

       --help[=FMT] (default=auto)
           Show this help in format FMT. The value FMT must be one of auto,
           pager, groff or plain. With auto, the format is pager or plain
           whenever the TERM env var is dumb or undefined.

       -q, --quiet
           Be quiet. Takes over -v and --verbosity.

       -v, --verbose
           Increase verbosity. Repeatable, but more than twice does not bring
           more.

       --verbosity=LEVEL (absent=warning or OWI_VERBOSITY env)
           Be more or less verbose. LEVEL must be one of quiet, error,
           warning, info or debug. Takes over -v.

       --version
           Show version information.

EXIT STATUS
       owi c++ exits with:

       0   on success.

       123 on indiscriminate errors reported on standard error.

       124 on command line parsing errors.

       125 on unexpected internal errors (bugs).

ENVIRONMENT
       These environment variables affect the execution of owi c++:

       OWI_VERBOSITY
           See option --verbosity.

BUGS
       Email them to &lt;contact@ndrs.fr&gt;.

SEE ALSO
       owi(1)

</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="owi-fmt"><a class="header" href="#owi-fmt"><code>owi fmt</code></a></h1>
<pre><code class="language-sh">$ owi fmt --help=plain
NAME
       owi-fmt - Format a .wat or .wast file

SYNOPSIS
       owi fmt [--inplace] [OPTION]‚Ä¶ FILE‚Ä¶

ARGUMENTS
       FILE (required)
           source files

OPTIONS
       -i, --inplace
           Format in-place, overwriting input file

COMMON OPTIONS
       --bench
           enable benchmarks

       --color=WHEN (absent=auto)
           Colorize the output. WHEN must be one of auto, always or never.

       --help[=FMT] (default=auto)
           Show this help in format FMT. The value FMT must be one of auto,
           pager, groff or plain. With auto, the format is pager or plain
           whenever the TERM env var is dumb or undefined.

       -q, --quiet
           Be quiet. Takes over -v and --verbosity.

       -v, --verbose
           Increase verbosity. Repeatable, but more than twice does not bring
           more.

       --verbosity=LEVEL (absent=warning or OWI_VERBOSITY env)
           Be more or less verbose. LEVEL must be one of quiet, error,
           warning, info or debug. Takes over -v.

       --version
           Show version information.

EXIT STATUS
       owi fmt exits with:

       0   on success.

       123 on indiscriminate errors reported on standard error.

       124 on command line parsing errors.

       125 on unexpected internal errors (bugs).

ENVIRONMENT
       These environment variables affect the execution of owi fmt:

       OWI_VERBOSITY
           See option --verbosity.

BUGS
       Email them to &lt;contact@ndrs.fr&gt;.

SEE ALSO
       owi(1)

</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="owi-instrument"><a class="header" href="#owi-instrument"><code>owi instrument</code></a></h1>
<pre><code class="language-sh">$ owi instrument --help=plain
NAME
       owi-instrument - Instrument a program in various ways

SYNOPSIS
       owi instrument COMMAND ‚Ä¶

COMMANDS
       label [--criteria=VAL] [--unsafe] [OPTION]‚Ä¶ FILE
           Generate an instrumented file with labels corresponding to test
           objectives for a given coverage criteria.

COMMON OPTIONS
       --help[=FMT] (default=auto)
           Show this help in format FMT. The value FMT must be one of auto,
           pager, groff or plain. With auto, the format is pager or plain
           whenever the TERM env var is dumb or undefined.

       --version
           Show version information.

EXIT STATUS
       owi instrument exits with:

       0   on success.

       123 on indiscriminate errors reported on standard error.

       124 on command line parsing errors.

       125 on unexpected internal errors (bugs).

BUGS
       Email them to &lt;contact@ndrs.fr&gt;.

SEE ALSO
       owi(1)

</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="owi-iso"><a class="header" href="#owi-iso"><code>owi iso</code></a></h1>
<pre><code class="language-sh">$ owi iso --help=plain
NAME
       owi-iso - Check the iso-functionnality of two Wasm modules by
       comparing the output when calling their exports.

SYNOPSIS
       owi iso [OPTION]‚Ä¶ FILE‚Ä¶

ARGUMENTS
       FILE (required)
           source files

OPTIONS
       --deterministic-result-order
           Guarantee a fixed deterministic order of found failures. This
           implies --no-stop-at-failure.

       --exploration=VAL (absent=fifo)
           exploration strategy to use ("fifo", "lifo", "random",
           "random-unseen-then-random", "rarity", "hot-path-penalty",
           "rarity-aging", "rarity-depth-aging", "rarity-depth-loop-aging",
           "rarity-depth-loop-aging-random")

       --fail-on-assertion-only
           ignore traps and only report assertion violations

       --fail-on-trap-only
           ignore assertion violations and only report traps

       --model-format=VAL (absent=scfg)
            The format of the model ("json" or "scfg")

       --model-out-file=FILE
           Output the generated model to FILE. if --no-stop-at-failure is
           given this is used as a prefix and the ouputed files would have
           PREFIX_%d.

       --no-assert-failure-expression-printing
           do not display the expression in the assert failure

       --no-stop-at-failure
           do not stop when a program failure is encountered

       --no-value
           do not display a value for each symbol

       --no-worker-isolation
           Do not force each worker to run on an isolated physical core.

       -s VALUE, --solver=VALUE (absent=Z3)
           SMT solver to use. VALUE must be one of the 5 available solvers:
           Z3, Bitwuzla, Colibri2, cvc5, Alt-Ergo

       -u, --unsafe
           skip typechecking pass

       -w VAL, --workers=VAL (absent=n)
           Number of workers for symbolic execution. Defaults to the number
           of physical cores.

       --with-breadcrumbs
           add breadcrumbs to the generated model

       --workspace=DIR
           write results and intermediate compilation artifacts to dir

COMMON OPTIONS
       --bench
           enable benchmarks

       --color=WHEN (absent=auto)
           Colorize the output. WHEN must be one of auto, always or never.

       --help[=FMT] (default=auto)
           Show this help in format FMT. The value FMT must be one of auto,
           pager, groff or plain. With auto, the format is pager or plain
           whenever the TERM env var is dumb or undefined.

       -q, --quiet
           Be quiet. Takes over -v and --verbosity.

       -v, --verbose
           Increase verbosity. Repeatable, but more than twice does not bring
           more.

       --verbosity=LEVEL (absent=warning or OWI_VERBOSITY env)
           Be more or less verbose. LEVEL must be one of quiet, error,
           warning, info or debug. Takes over -v.

       --version
           Show version information.

EXIT STATUS
       owi iso exits with:

       0   on success.

       123 on indiscriminate errors reported on standard error.

       124 on command line parsing errors.

       125 on unexpected internal errors (bugs).

ENVIRONMENT
       These environment variables affect the execution of owi iso:

       OWI_VERBOSITY
           See option --verbosity.

BUGS
       Email them to &lt;contact@ndrs.fr&gt;.

SEE ALSO
       owi(1)

</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="owi-replay"><a class="header" href="#owi-replay"><code>owi replay</code></a></h1>
<pre><code class="language-sh">$ owi replay --help=plain
NAME
       owi-replay - Replay a module containing symbols with concrete values
       in a replay file containing a model

SYNOPSIS
       owi replay [OPTION]‚Ä¶ FILE

ARGUMENTS
       FILE (required)
           source file

OPTIONS
       --entry-point=FUNCTION
           entry point of the executable

       --invoke-with-symbols
           Invoke the entry point of the program with symbolic values instead
           of dummy constants.

       --replay-file=FILE (required)
           Which replay file to use

       -u, --unsafe
           skip typechecking pass

COMMON OPTIONS
       --bench
           enable benchmarks

       --color=WHEN (absent=auto)
           Colorize the output. WHEN must be one of auto, always or never.

       --help[=FMT] (default=auto)
           Show this help in format FMT. The value FMT must be one of auto,
           pager, groff or plain. With auto, the format is pager or plain
           whenever the TERM env var is dumb or undefined.

       -q, --quiet
           Be quiet. Takes over -v and --verbosity.

       -v, --verbose
           Increase verbosity. Repeatable, but more than twice does not bring
           more.

       --verbosity=LEVEL (absent=warning or OWI_VERBOSITY env)
           Be more or less verbose. LEVEL must be one of quiet, error,
           warning, info or debug. Takes over -v.

       --version
           Show version information.

EXIT STATUS
       owi replay exits with:

       0   on success.

       123 on indiscriminate errors reported on standard error.

       124 on command line parsing errors.

       125 on unexpected internal errors (bugs).

ENVIRONMENT
       These environment variables affect the execution of owi replay:

       OWI_VERBOSITY
           See option --verbosity.

BUGS
       Email them to &lt;contact@ndrs.fr&gt;.

SEE ALSO
       owi(1)

</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="owi-run"><a class="header" href="#owi-run"><code>owi run</code></a></h1>
<pre><code class="language-sh">$ owi run --help=plain
NAME
       owi-run - Run the concrete interpreter

SYNOPSIS
       owi run [--timeout=S] [--timeout-instr=I] [--unsafe] [OPTION]‚Ä¶ FILE

ARGUMENTS
       FILE (required)
           source file

OPTIONS
       --timeout=S
           Stop execution after S seconds.

       --timeout-instr=I
           Stop execution after running I instructions.

       -u, --unsafe
           skip typechecking pass

COMMON OPTIONS
       --bench
           enable benchmarks

       --color=WHEN (absent=auto)
           Colorize the output. WHEN must be one of auto, always or never.

       --help[=FMT] (default=auto)
           Show this help in format FMT. The value FMT must be one of auto,
           pager, groff or plain. With auto, the format is pager or plain
           whenever the TERM env var is dumb or undefined.

       -q, --quiet
           Be quiet. Takes over -v and --verbosity.

       -v, --verbose
           Increase verbosity. Repeatable, but more than twice does not bring
           more.

       --verbosity=LEVEL (absent=warning or OWI_VERBOSITY env)
           Be more or less verbose. LEVEL must be one of quiet, error,
           warning, info or debug. Takes over -v.

       --version
           Show version information.

EXIT STATUS
       owi run exits with:

       0   on success.

       123 on indiscriminate errors reported on standard error.

       124 on command line parsing errors.

       125 on unexpected internal errors (bugs).

ENVIRONMENT
       These environment variables affect the execution of owi run:

       OWI_VERBOSITY
           See option --verbosity.

BUGS
       Email them to &lt;contact@ndrs.fr&gt;.

SEE ALSO
       owi(1)

</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="owi-rust"><a class="header" href="#owi-rust"><code>owi rust</code></a></h1>
<pre><code class="language-sh">$ owi rust --help=plain
NAME
       owi-rust - Compile a Rust file to Wasm and run the symbolic
       interpreter on it

SYNOPSIS
       owi rust [OPTION]‚Ä¶ FILE‚Ä¶

ARGUMENTS
       FILE (required)
           source files

OPTIONS
       --deterministic-result-order
           Guarantee a fixed deterministic order of found failures. This
           implies --no-stop-at-failure.

       --entry-point=FUNCTION (absent=main)
           entry point of the executable

       --exploration=VAL (absent=fifo)
           exploration strategy to use ("fifo", "lifo", "random",
           "random-unseen-then-random", "rarity", "hot-path-penalty",
           "rarity-aging", "rarity-depth-aging", "rarity-depth-loop-aging",
           "rarity-depth-loop-aging-random")

       --fail-on-assertion-only
           ignore traps and only report assertion violations

       --fail-on-trap-only
           ignore assertion violations and only report traps

       -I VAL
           headers path

       --invoke-with-symbols
           Invoke the entry point of the program with symbolic values instead
           of dummy constants.

       -m VAL, --arch=VAL (absent=32)
           data model

       --model-format=VAL (absent=scfg)
            The format of the model ("json" or "scfg")

       --model-out-file=FILE
           Output the generated model to FILE. if --no-stop-at-failure is
           given this is used as a prefix and the ouputed files would have
           PREFIX_%d.

       --no-assert-failure-expression-printing
           do not display the expression in the assert failure

       --no-ite-for-select
           do not use ite for select

       --no-stop-at-failure
           do not stop when a program failure is encountered

       --no-value
           do not display a value for each symbol

       --no-worker-isolation
           Do not force each worker to run on an isolated physical core.

       -o FILE, --output=FILE
           Output the generated .wasm or .wat to FILE.

       -O VAL (absent=3)
           specify which optimization level to use

       -s VALUE, --solver=VALUE (absent=Z3)
           SMT solver to use. VALUE must be one of the 5 available solvers:
           Z3, Bitwuzla, Colibri2, cvc5, Alt-Ergo

       -u, --unsafe
           skip typechecking pass

       -w VAL, --workers=VAL (absent=n)
           Number of workers for symbolic execution. Defaults to the number
           of physical cores.

       --with-breadcrumbs
           add breadcrumbs to the generated model

       --workspace=DIR
           write results and intermediate compilation artifacts to dir

COMMON OPTIONS
       --bench
           enable benchmarks

       --color=WHEN (absent=auto)
           Colorize the output. WHEN must be one of auto, always or never.

       --help[=FMT] (default=auto)
           Show this help in format FMT. The value FMT must be one of auto,
           pager, groff or plain. With auto, the format is pager or plain
           whenever the TERM env var is dumb or undefined.

       -q, --quiet
           Be quiet. Takes over -v and --verbosity.

       -v, --verbose
           Increase verbosity. Repeatable, but more than twice does not bring
           more.

       --verbosity=LEVEL (absent=warning or OWI_VERBOSITY env)
           Be more or less verbose. LEVEL must be one of quiet, error,
           warning, info or debug. Takes over -v.

       --version
           Show version information.

EXIT STATUS
       owi rust exits with:

       0   on success.

       123 on indiscriminate errors reported on standard error.

       124 on command line parsing errors.

       125 on unexpected internal errors (bugs).

ENVIRONMENT
       These environment variables affect the execution of owi rust:

       OWI_VERBOSITY
           See option --verbosity.

BUGS
       Email them to &lt;contact@ndrs.fr&gt;.

SEE ALSO
       owi(1)

</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="owi-script"><a class="header" href="#owi-script"><code>owi script</code></a></h1>
<pre><code class="language-sh">$ owi script --help=plain
NAME
       owi-script - Run a reference test suite script

SYNOPSIS
       owi script [--no-exhaustion] [OPTION]‚Ä¶ FILE‚Ä¶

ARGUMENTS
       FILE (required)
           source files

OPTIONS
       --no-exhaustion
           no exhaustion tests

COMMON OPTIONS
       --bench
           enable benchmarks

       --color=WHEN (absent=auto)
           Colorize the output. WHEN must be one of auto, always or never.

       --help[=FMT] (default=auto)
           Show this help in format FMT. The value FMT must be one of auto,
           pager, groff or plain. With auto, the format is pager or plain
           whenever the TERM env var is dumb or undefined.

       -q, --quiet
           Be quiet. Takes over -v and --verbosity.

       -v, --verbose
           Increase verbosity. Repeatable, but more than twice does not bring
           more.

       --verbosity=LEVEL (absent=warning or OWI_VERBOSITY env)
           Be more or less verbose. LEVEL must be one of quiet, error,
           warning, info or debug. Takes over -v.

       --version
           Show version information.

EXIT STATUS
       owi script exits with:

       0   on success.

       123 on indiscriminate errors reported on standard error.

       124 on command line parsing errors.

       125 on unexpected internal errors (bugs).

ENVIRONMENT
       These environment variables affect the execution of owi script:

       OWI_VERBOSITY
           See option --verbosity.

BUGS
       Email them to &lt;contact@ndrs.fr&gt;.

SEE ALSO
       owi(1)

</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="owi-sym"><a class="header" href="#owi-sym"><code>owi sym</code></a></h1>
<pre><code class="language-sh">$ owi sym --help=plain
NAME
       owi-sym - Run the symbolic interpreter

SYNOPSIS
       owi sym [OPTION]‚Ä¶ FILE

ARGUMENTS
       FILE (required)
           source file

OPTIONS
       --deterministic-result-order
           Guarantee a fixed deterministic order of found failures. This
           implies --no-stop-at-failure.

       --entry-point=FUNCTION
           entry point of the executable

       --exploration=VAL (absent=fifo)
           exploration strategy to use ("fifo", "lifo", "random",
           "random-unseen-then-random", "rarity", "hot-path-penalty",
           "rarity-aging", "rarity-depth-aging", "rarity-depth-loop-aging",
           "rarity-depth-loop-aging-random")

       --fail-on-assertion-only
           ignore traps and only report assertion violations

       --fail-on-trap-only
           ignore assertion violations and only report traps

       --invoke-with-symbols
           Invoke the entry point of the program with symbolic values instead
           of dummy constants.

       --model-format=VAL (absent=scfg)
            The format of the model ("json" or "scfg")

       --model-out-file=FILE
           Output the generated model to FILE. if --no-stop-at-failure is
           given this is used as a prefix and the ouputed files would have
           PREFIX_%d.

       --no-assert-failure-expression-printing
           do not display the expression in the assert failure

       --no-ite-for-select
           do not use ite for select

       --no-stop-at-failure
           do not stop when a program failure is encountered

       --no-value
           do not display a value for each symbol

       --no-worker-isolation
           Do not force each worker to run on an isolated physical core.

       -s VALUE, --solver=VALUE (absent=Z3)
           SMT solver to use. VALUE must be one of the 5 available solvers:
           Z3, Bitwuzla, Colibri2, cvc5, Alt-Ergo

       -u, --unsafe
           skip typechecking pass

       -w VAL, --workers=VAL (absent=n)
           Number of workers for symbolic execution. Defaults to the number
           of physical cores.

       --with-breadcrumbs
           add breadcrumbs to the generated model

       --workspace=DIR
           write results and intermediate compilation artifacts to dir

COMMON OPTIONS
       --bench
           enable benchmarks

       --color=WHEN (absent=auto)
           Colorize the output. WHEN must be one of auto, always or never.

       --help[=FMT] (default=auto)
           Show this help in format FMT. The value FMT must be one of auto,
           pager, groff or plain. With auto, the format is pager or plain
           whenever the TERM env var is dumb or undefined.

       -q, --quiet
           Be quiet. Takes over -v and --verbosity.

       -v, --verbose
           Increase verbosity. Repeatable, but more than twice does not bring
           more.

       --verbosity=LEVEL (absent=warning or OWI_VERBOSITY env)
           Be more or less verbose. LEVEL must be one of quiet, error,
           warning, info or debug. Takes over -v.

       --version
           Show version information.

EXIT STATUS
       owi sym exits with:

       0   on success.

       123 on indiscriminate errors reported on standard error.

       124 on command line parsing errors.

       125 on unexpected internal errors (bugs).

ENVIRONMENT
       These environment variables affect the execution of owi sym:

       OWI_VERBOSITY
           See option --verbosity.

BUGS
       Email them to &lt;contact@ndrs.fr&gt;.

SEE ALSO
       owi(1)

</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="owi-validate"><a class="header" href="#owi-validate"><code>owi validate</code></a></h1>
<pre><code class="language-sh">$ owi validate --help=plain
NAME
       owi-validate - Validate a module

SYNOPSIS
       owi validate [OPTION]‚Ä¶ FILE‚Ä¶

ARGUMENTS
       FILE (required)
           source files

COMMON OPTIONS
       --bench
           enable benchmarks

       --color=WHEN (absent=auto)
           Colorize the output. WHEN must be one of auto, always or never.

       --help[=FMT] (default=auto)
           Show this help in format FMT. The value FMT must be one of auto,
           pager, groff or plain. With auto, the format is pager or plain
           whenever the TERM env var is dumb or undefined.

       -q, --quiet
           Be quiet. Takes over -v and --verbosity.

       -v, --verbose
           Increase verbosity. Repeatable, but more than twice does not bring
           more.

       --verbosity=LEVEL (absent=warning or OWI_VERBOSITY env)
           Be more or less verbose. LEVEL must be one of quiet, error,
           warning, info or debug. Takes over -v.

       --version
           Show version information.

EXIT STATUS
       owi validate exits with:

       0   on success.

       123 on indiscriminate errors reported on standard error.

       124 on command line parsing errors.

       125 on unexpected internal errors (bugs).

ENVIRONMENT
       These environment variables affect the execution of owi validate:

       OWI_VERBOSITY
           See option --verbosity.

BUGS
       Email them to &lt;contact@ndrs.fr&gt;.

SEE ALSO
       owi(1)

</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="owi-version"><a class="header" href="#owi-version"><code>owi version</code></a></h1>
<pre><code class="language-sh">$ owi version --help=plain
NAME
       owi-version - Print some version informations

SYNOPSIS
       owi version [OPTION]‚Ä¶

COMMON OPTIONS
       --bench
           enable benchmarks

       --color=WHEN (absent=auto)
           Colorize the output. WHEN must be one of auto, always or never.

       --help[=FMT] (default=auto)
           Show this help in format FMT. The value FMT must be one of auto,
           pager, groff or plain. With auto, the format is pager or plain
           whenever the TERM env var is dumb or undefined.

       -q, --quiet
           Be quiet. Takes over -v and --verbosity.

       -v, --verbose
           Increase verbosity. Repeatable, but more than twice does not bring
           more.

       --verbosity=LEVEL (absent=warning or OWI_VERBOSITY env)
           Be more or less verbose. LEVEL must be one of quiet, error,
           warning, info or debug. Takes over -v.

       --version
           Show version information.

EXIT STATUS
       owi version exits with:

       0   on success.

       123 on indiscriminate errors reported on standard error.

       124 on command line parsing errors.

       125 on unexpected internal errors (bugs).

ENVIRONMENT
       These environment variables affect the execution of owi version:

       OWI_VERBOSITY
           See option --verbosity.

BUGS
       Email them to &lt;contact@ndrs.fr&gt;.

SEE ALSO
       owi(1)

</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="owi-wasm2wat"><a class="header" href="#owi-wasm2wat"><code>owi wasm2wat</code></a></h1>
<pre><code class="language-sh">$ owi wasm2wat --help=plain
NAME
       owi-wasm2wat - Generate a text format file (.wat) from a binary format
       file (.wasm)

SYNOPSIS
       owi wasm2wat [--emit-file] [--output=FILE] [OPTION]‚Ä¶ FILE

ARGUMENTS
       FILE (required)
           source file

OPTIONS
       --emit-file
           Emit (.wat) files from corresponding (.wasm) files.

       -o FILE, --output=FILE
           Output the generated .wasm or .wat to FILE.

COMMON OPTIONS
       --bench
           enable benchmarks

       --color=WHEN (absent=auto)
           Colorize the output. WHEN must be one of auto, always or never.

       --help[=FMT] (default=auto)
           Show this help in format FMT. The value FMT must be one of auto,
           pager, groff or plain. With auto, the format is pager or plain
           whenever the TERM env var is dumb or undefined.

       -q, --quiet
           Be quiet. Takes over -v and --verbosity.

       -v, --verbose
           Increase verbosity. Repeatable, but more than twice does not bring
           more.

       --verbosity=LEVEL (absent=warning or OWI_VERBOSITY env)
           Be more or less verbose. LEVEL must be one of quiet, error,
           warning, info or debug. Takes over -v.

       --version
           Show version information.

EXIT STATUS
       owi wasm2wat exits with:

       0   on success.

       123 on indiscriminate errors reported on standard error.

       124 on command line parsing errors.

       125 on unexpected internal errors (bugs).

ENVIRONMENT
       These environment variables affect the execution of owi wasm2wat:

       OWI_VERBOSITY
           See option --verbosity.

BUGS
       Email them to &lt;contact@ndrs.fr&gt;.

SEE ALSO
       owi(1)

</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="owi-wat2wasm"><a class="header" href="#owi-wat2wasm"><code>owi wat2wasm</code></a></h1>
<pre><code class="language-sh">$ owi wat2wasm --help=plain
NAME
       owi-wat2wasm - Generate a binary format file (.wasm) from a text
       format file (.wat)

SYNOPSIS
       owi wat2wasm [--output=FILE] [--unsafe] [OPTION]‚Ä¶ FILE

ARGUMENTS
       FILE (required)
           source file

OPTIONS
       -o FILE, --output=FILE
           Output the generated .wasm or .wat to FILE.

       -u, --unsafe
           skip typechecking pass

COMMON OPTIONS
       --bench
           enable benchmarks

       --color=WHEN (absent=auto)
           Colorize the output. WHEN must be one of auto, always or never.

       --help[=FMT] (default=auto)
           Show this help in format FMT. The value FMT must be one of auto,
           pager, groff or plain. With auto, the format is pager or plain
           whenever the TERM env var is dumb or undefined.

       -q, --quiet
           Be quiet. Takes over -v and --verbosity.

       -v, --verbose
           Increase verbosity. Repeatable, but more than twice does not bring
           more.

       --verbosity=LEVEL (absent=warning or OWI_VERBOSITY env)
           Be more or less verbose. LEVEL must be one of quiet, error,
           warning, info or debug. Takes over -v.

       --version
           Show version information.

EXIT STATUS
       owi wat2wasm exits with:

       0   on success.

       123 on indiscriminate errors reported on standard error.

       124 on command line parsing errors.

       125 on unexpected internal errors (bugs).

ENVIRONMENT
       These environment variables affect the execution of owi wat2wasm:

       OWI_VERBOSITY
           See option --verbosity.

BUGS
       Email them to &lt;contact@ndrs.fr&gt;.

SEE ALSO
       owi(1)

</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="owi-zig"><a class="header" href="#owi-zig"><code>owi zig</code></a></h1>
<pre><code class="language-sh">$ owi zig --help=plain
NAME
       owi-zig - Compile a Zig file to Wasm and run the symbolic interpreter
       on it

SYNOPSIS
       owi zig [OPTION]‚Ä¶ FILE‚Ä¶

ARGUMENTS
       FILE (required)
           source files

OPTIONS
       --deterministic-result-order
           Guarantee a fixed deterministic order of found failures. This
           implies --no-stop-at-failure.

       --entry-point=FUNCTION (absent=_start)
           entry point of the executable

       --exploration=VAL (absent=fifo)
           exploration strategy to use ("fifo", "lifo", "random",
           "random-unseen-then-random", "rarity", "hot-path-penalty",
           "rarity-aging", "rarity-depth-aging", "rarity-depth-loop-aging",
           "rarity-depth-loop-aging-random")

       --fail-on-assertion-only
           ignore traps and only report assertion violations

       --fail-on-trap-only
           ignore assertion violations and only report traps

       -I VAL
           headers path

       --invoke-with-symbols
           Invoke the entry point of the program with symbolic values instead
           of dummy constants.

       --model-format=VAL (absent=scfg)
            The format of the model ("json" or "scfg")

       --model-out-file=FILE
           Output the generated model to FILE. if --no-stop-at-failure is
           given this is used as a prefix and the ouputed files would have
           PREFIX_%d.

       --no-assert-failure-expression-printing
           do not display the expression in the assert failure

       --no-ite-for-select
           do not use ite for select

       --no-stop-at-failure
           do not stop when a program failure is encountered

       --no-value
           do not display a value for each symbol

       --no-worker-isolation
           Do not force each worker to run on an isolated physical core.

       -o FILE, --output=FILE
           Output the generated .wasm or .wat to FILE.

       -s VALUE, --solver=VALUE (absent=Z3)
           SMT solver to use. VALUE must be one of the 5 available solvers:
           Z3, Bitwuzla, Colibri2, cvc5, Alt-Ergo

       -u, --unsafe
           skip typechecking pass

       -w VAL, --workers=VAL (absent=n)
           Number of workers for symbolic execution. Defaults to the number
           of physical cores.

       --with-breadcrumbs
           add breadcrumbs to the generated model

       --workspace=DIR
           write results and intermediate compilation artifacts to dir

COMMON OPTIONS
       --bench
           enable benchmarks

       --color=WHEN (absent=auto)
           Colorize the output. WHEN must be one of auto, always or never.

       --help[=FMT] (default=auto)
           Show this help in format FMT. The value FMT must be one of auto,
           pager, groff or plain. With auto, the format is pager or plain
           whenever the TERM env var is dumb or undefined.

       -q, --quiet
           Be quiet. Takes over -v and --verbosity.

       -v, --verbose
           Increase verbosity. Repeatable, but more than twice does not bring
           more.

       --verbosity=LEVEL (absent=warning or OWI_VERBOSITY env)
           Be more or less verbose. LEVEL must be one of quiet, error,
           warning, info or debug. Takes over -v.

       --version
           Show version information.

EXIT STATUS
       owi zig exits with:

       0   on success.

       123 on indiscriminate errors reported on standard error.

       124 on command line parsing errors.

       125 on unexpected internal errors (bugs).

ENVIRONMENT
       These environment variables affect the execution of owi zig:

       OWI_VERBOSITY
           See option --verbosity.

BUGS
       Email them to &lt;contact@ndrs.fr&gt;.

SEE ALSO
       owi(1)

</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="overview-1"><a class="header" href="#overview-1">Overview</a></h1>
<p>Given a file <code>quickstart.wat</code>, here‚Äôs how to parse and run this file:</p>
<pre><code class="language-ocaml"># open Prelude;;
# open Owi;;
# Fmt_tty.setup_std_outputs ();;
- : unit = ()
# Logs.set_level ~all:true (Some Logs.Info);;
- : unit = ()
# Logs.set_reporter (Logs_fmt.reporter ())
- : unit = ()
# let filename = Fpath.v "quickstart.wat";;
val filename : Fpath.t = &lt;abstr&gt;
# let m =
    match Parse.Text.Module.from_file filename with
    | Ok script -&gt; script
    | Error e -&gt; assert false;;
mdx_gen.bc.exe: [INFO] parsing      ...
...
# let module_to_run, link_state =
    match Compile.Text.until_link (Link.State.empty ()) ~unsafe:false ~name:None m with
    | Ok v -&gt; v
    | Error _ -&gt; assert false;;
mdx_gen.bc.exe: [INFO] checking     ...
mdx_gen.bc.exe: [INFO] typechecking ...
...
mdx_gen.bc.exe: [INFO] linking      ...
...
# module I = Interpret.Concrete (Interpret.Default_parameters);;
module I :
  sig
    val modul :
      Concrete_extern_func.extern_func Link.State.t -&gt;
      Concrete_extern_func.extern_func Linked.Module.t -&gt; unit Owi.Result.t
  end
# let () =
    match I.modul link_state module_to_run with
    | Ok () -&gt; ()
    | Error _ -&gt; assert false;;
mdx_gen.bc.exe: [INFO] interpreting ...
mdx_gen.bc.exe: [INFO] stack         : [  ]
mdx_gen.bc.exe: [INFO] running instr : call 0 (executed 0 times)
mdx_gen.bc.exe: [INFO] calling func  : func f
mdx_gen.bc.exe: [INFO] stack         : [  ]
mdx_gen.bc.exe: [INFO] running instr : i32.const 24 (executed 0 times)
mdx_gen.bc.exe: [INFO] stack         : [ i32.const 24 ]
mdx_gen.bc.exe: [INFO] running instr : i32.const 24 (executed 0 times)
mdx_gen.bc.exe: [INFO] stack         : [ i32.const 24 ; i32.const 24 ]
mdx_gen.bc.exe: [INFO] running instr : i32.add (executed 0 times)
mdx_gen.bc.exe: [INFO] stack         : [ i32.const 48 ]
mdx_gen.bc.exe: [INFO] running instr : drop (executed 0 times)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="using-and-defining-external-functions-host-functions"><a class="header" href="#using-and-defining-external-functions-host-functions">Using and defining external functions (host functions)</a></h1>
<h2 id="dealing-with-the-stack"><a class="header" href="#dealing-with-the-stack">Dealing with the Stack</a></h2>
<p>Given the following <code>extern.wat</code> file:</p>
<!-- $MDX file=extern.wat -->
<pre><code class="language-wat">(module $extern

  (import "sausage" "fresh"
    (func $fresh (param i32) (result externref)))

  (import "sausage" "get_i32r"
    (func $get (param externref) (result i32)))

  (import "sausage" "set_i32r"
    (func $set (param externref) (param i32)))

  (import "sausage" "print_i32"
    (func $print_i32 (param i32)))

  (func $start (local $ref externref)

    ;; let ref = fresh 42
    (local.set $ref (call $fresh (i32.const 42)))

    ;; print_i32 (get ref)
    (call $print_i32 (call $get (local.get $ref)))

    ;; set ref 13
    (call $set (local.get $ref) (i32.const 13)  )

    ;; print_i32 (get ref)
    (call $print_i32 (call $get (local.get $ref)))

  )

  (start $start)
)
</code></pre>
<p>You can define the various required external functions in OCaml like this :</p>
<!-- $MDX file=extern.ml -->
<pre><code class="language-ocaml">open Owi

(* an extern module that will be linked with a wasm module *)
let extern_module : Concrete_extern_func.extern_func Extern.Module.t =
  (* some custom functions *)
  let rint : Concrete_i32.t ref Type.Id.t = Type.Id.make () in
  let fresh i = Ok (ref i) in
  let set r (i : Concrete_i32.t) =
    r := i;
    Ok ()
  in
  let get r = Ok !r in
  let print_i32 (i : Concrete_i32.t) =
    Format.printf "%a\n%!" Concrete_i32.pp i;
    Ok ()
  in
  (* we need to describe their types *)
  let open Concrete_extern_func.Syntax in
  let functions =
    [ ("print_i32", Concrete_extern_func.Extern_func (i32 ^-&gt;. unit, print_i32))
    ; ( "fresh"
      , Concrete_extern_func.Extern_func (i32 ^-&gt;. externref rint, fresh) )
    ; ( "set_i32r"
      , Concrete_extern_func.Extern_func (externref rint ^-&gt; i32 ^-&gt;. unit, set)
      )
    ; ( "get_i32r"
      , Concrete_extern_func.Extern_func (externref rint ^-&gt;. i32, get) )
    ]
  in
  { functions; func_type = Concrete_extern_func.extern_type }

(* a link state that contains our custom module, available under the name `sausage` *)
let link_state =
  Link.State.empty () |&gt; Link.Extern.modul ~name:"sausage" extern_module

(* a pure wasm module refering to `sausage` *)
let pure_wasm_module =
  match Parse.Text.Module.from_file (Fpath.v "extern.wat") with
  | Error _ -&gt; assert false
  | Ok modul -&gt; modul

(* our pure wasm module, linked with `sausage` *)
let module_to_run, link_state =
  match
    Compile.Text.until_link link_state ~unsafe:false ~name:None pure_wasm_module
  with
  | Error _ -&gt; assert false
  | Ok v -&gt; v

module I = Interpret.Concrete (Interpret.Default_parameters)

(* let's run it ! it will print the values as defined in the print_i32 function *)
let () =
  match I.modul link_state module_to_run with
  | Error _o -&gt; assert false
  | Ok () -&gt; ()
</code></pre>
<p>You‚Äôll get the expected result:</p>
<pre><code class="language-sh">$ ./extern.exe
42
13
</code></pre>
<h2 id="dealing-with-the-linear-memory"><a class="header" href="#dealing-with-the-linear-memory">Dealing with the Linear Memory</a></h2>
<p>Owi also allows interacting with linear memory through external functions.
This is helpful because it enables the host system to communicate directly
with a Wasm instance through its linear memory. Consider the tiny example
below to illustrate this:</p>
<!-- $MDX file=extern_mem.wat -->
<pre><code class="language-wat">(module $extern_mem

  (import "chorizo" "memset" (func $memset (param i32 i32 i32)))

  (import "chorizo" "print_x64" (func $print_x64 (param i64)))

  (memory 1)

  (func $start

    ;; memset 0 0xAA 8
    (call $memset (i32.const 0) (i32.const 0xAA) (i32.const 8))

    ;; print_x64 (load 0)
    (call $print_x64 (i64.load (i32.const 0)))
  )

  (start $start)
)
</code></pre>
<p>In the module <code>$extern_mem</code>, we first import <code>$memset</code> and <code>$print_x64</code>. Then,
in the <code>$start</code> function, we initialize the memory starting at address
<code>(i32.const 0)</code> with a sequence of length <code>(i32.const 8)</code> with bytes of
<code>(i32.const 0xAA)</code>.</p>
<p>The definition of the external functions follows the same format as the
<a href="ocaml-api/README.html#dealing-with-the-stack">previous example</a>. The difference is that, now, in the GADT definition of
memset to allow the memory to be passed to this function, we need to wrap
the three I32 arguments in a Mem variant. That is, instead of writing
memset as:</p>
<!-- $MDX skip -->
<pre><code class="language-ocaml">(Func (Arg (I32, (Arg (I32, (Arg (I32, Res))))), R0), memset)
</code></pre>
<p>One should use:</p>
<!-- $MDX skip -->
<pre><code class="language-ocaml">(Func (Mem (Arg (I32, (Arg (I32, (Arg (I32, Res)))))), R0), memset)
</code></pre>
<p>See the module below for the whole implementation:</p>
<!-- $MDX file=extern_mem.ml -->
<pre><code class="language-ocaml">open Owi

(* an extern module that will be linked with a wasm module *)
let extern_module : Concrete_extern_func.extern_func Extern.Module.t =
  (* some custom functions *)
  let memset m start byte length =
    let rec loop offset =
      let b = Concrete_i32.le offset length |&gt; Concrete_boolean.to_bool in
      if b then begin
        match
          Concrete_memory.store_8 m ~addr:(Concrete_i32.add start offset) byte
        with
        | Error _ as e -&gt; e
        | Ok () -&gt; loop (Concrete_i32.add offset (Concrete_i32.of_int 1))
      end
      else Ok ()
    in
    loop Concrete_i32.zero
  in
  let print_x64 (n : Concrete_i64.t) =
    let n = Concrete_i64.to_int64 n in
    Format.printf "0x%LX@\n" n;
    Ok ()
  in
  (* we need to describe their types *)
  let open Concrete_extern_func in
  let open Concrete_extern_func.Syntax in
  let functions =
    [ ("print_x64", Extern_func (i64 ^-&gt;. unit, print_x64))
    ; ( "memset"
      , Extern_func (memory 0 ^-&gt; i32 ^-&gt; i32 ^-&gt; i32 ^-&gt;. unit, memset) )
    ]
  in
  { Extern.Module.functions; func_type = Concrete_extern_func.extern_type }

(* a link state that contains our custom module, available under the name `chorizo` *)
let link_state =
  Link.State.empty () |&gt; Link.Extern.modul ~name:"chorizo" extern_module

(* a pure wasm module refering to `$extern_mem` *)
let pure_wasm_module =
  match Parse.Text.Module.from_file (Fpath.v "extern_mem.wat") with
  | Error _ -&gt; assert false
  | Ok modul -&gt; modul

(* our pure wasm module, linked with `chorizo` *)
let module_to_run, link_state =
  match
    Compile.Text.until_link link_state ~unsafe:false ~name:None pure_wasm_module
  with
  | Error _ -&gt; assert false
  | Ok v -&gt; v

module I = Interpret.Concrete (Interpret.Default_parameters)

(* let's run it ! it will print the values as defined in the print_i64 function *)
let () =
  match I.modul link_state module_to_run with
  | Error _ -&gt; assert false
  | Ok () -&gt; ()
</code></pre>
<p>Running the above program should yield:</p>
<pre><code class="language-sh">$ ./extern_mem.exe
0xAAAAAAAAAAAAAAAA
</code></pre>
<h2 id="advanced-usage"><a class="header" href="#advanced-usage">Advanced Usage</a></h2>
<p>To learn more, see our advanced <a href="ocaml-api/life_game">Game of Life</a> example
based on the famous cellular automaton by Conway. It show how to link several modules from different <code>.wat</code> files.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="generated-api-documentation"><a class="header" href="#generated-api-documentation">Generated API Documentation</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="development-setup"><a class="header" href="#development-setup">Development Setup</a></h1>
<p>To get a proper development setup:</p>
<pre><code class="language-shell-session">$ git clone git@github.com:OCamlPro/owi.git
$ cd owi
$ opam install . --deps-only --with-test --with-doc --with-dev-setup
$ git submodule update --init --recursive
$ dune build @all
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="coding-guidelines"><a class="header" href="#coding-guidelines">Coding Guidelines</a></h1>
<h2 id="the-prelude-library"><a class="header" href="#the-prelude-library">The <code>prelude</code> library</a></h2>
<p>We use the <a href="https://git.zapashcanon.fr/zapashcanon/prelude"><code>prelude</code></a> library to <strong>hide dangerous functions</strong> from the standard library.
It is automatically opened in the whole project.
More than dangerous functions, this library also hide some modules for which better alternatives exists.
For instance, all system interactions are done using <a href="https://erratique.ch/software/bos/doc/"><code>Bos</code></a> and all the formatting is done with <a href="https://erratique.ch/software/fmt/doc/"><code>Fmt</code></a>.</p>
<h2 id="printing"><a class="header" href="#printing">Printing</a></h2>
<p>Read the <a href="https://erratique.ch/software/logs/doc/Logs/index.html#basics">Logs basics</a> and in particular, the <a href="https://erratique.ch/software/logs/doc/Logs/index.html#usage">usage conventions</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="documentation"><a class="header" href="#documentation">Documentation</a></h1>
<h2 id="api"><a class="header" href="#api">API</a></h2>
<p>You can build the documentation with:</p>
<pre><code class="language-shell-session">$ dune build @doc
$ xdg-open _build/default/doc/index.html
</code></pre>
<h2 id="full-documentation"><a class="header" href="#full-documentation">Full documentation</a></h2>
<pre><code class="language-shell-session">$ cd ./doc
$ mdbook serve
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="testing"><a class="header" href="#testing">Testing</a></h1>
<h2 id="unit-tests"><a class="header" href="#unit-tests">Unit tests</a></h2>
<p>Tests are mostly written using <a href="https://dune.readthedocs.io/en/latest/reference/cram.html">Cram Tests</a>.
The ones that are integrated into documentation are using <a href="https://github.com/realworldocaml/mdx">MDX</a>.
You can run them as follow:</p>
<pre><code class="language-shell-session">$ dune runtest
</code></pre>
<p>If you made some changes and the output of some tests is changing, the diff will be displayed.
If you want to automatically accept the diff as being the new expected output, you can run:</p>
<pre><code class="language-shell-session">$ dune promote
</code></pre>
<h2 id="code-coverage"><a class="header" href="#code-coverage">Code coverage</a></h2>
<p>You can generate the code coverage report with:</p>
<pre><code class="language-shell-session">BISECT_FILE=$(pwd)/bisect odune runtest --force --instrument-with bisect_ppx
bisect-ppx-report html -o _coverage
xdg-open _coverage/index.html
</code></pre>
<h2 id="fuzzing"><a class="header" href="#fuzzing">Fuzzing</a></h2>
<p>See <a href="https://github.com/OCamlPro/owi/tree/main/test/fuzz">test/fuzz</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="benchmarking"><a class="header" href="#benchmarking">Benchmarking</a></h1>
<h2 id="landmarks"><a class="header" href="#landmarks">Landmarks</a></h2>
<pre><code class="language-shell-session">OCAML_LANDMARKS=on dune exec --instrument-with landmarks --profile release -- owi run test/run/binary_loop.wasm
</code></pre>
<p>See the discussion in <a href="https://github.com/OCamlPro/owi/pull/871">#871</a> to understand landmarks limitations in Owi.</p>
<h2 id="test-comp"><a class="header" href="#test-comp">Test-comp</a></h2>
<p>See <a href="https://github.com/OCamlPro/symbocalypse">Symbocalypse</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="history-of-owi"><a class="header" href="#history-of-owi">History of Owi</a></h1>
<h3 id="spelling-and-pronunciation"><a class="header" href="#spelling-and-pronunciation">Spelling and pronunciation</a></h3>
<p>Although the name Owi comes from an acronym (OCaml WebAssembly Interpreter), it must be written as a proper noun and only the first letter must be capitalized. It is possible to write the name in full lowercase when referring to the opam package or to the name of the binary.</p>
<p>The reason we chose this spelling rather than the fully capitalized version is that in French, Owi is pronounced [o‚Äôwi( É)] which sounds like ‚ÄúOh oui !‚Äù which means ‚ÄúOh yes!‚Äù. Thus it should be pronounced this way and not by spelling the three letters it is made of.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="authors-and-contributors"><a class="header" href="#authors-and-contributors">Authors and Contributors</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="license"><a class="header" href="#license">License</a></h1>
<pre><code>Owi
Copyright (C) 2021-2024 OCamlPro

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
</code></pre>
<p>See <a href="https://github.com/OCamlPro/owi/blob/main/LICENSE.md">LICENSE</a>.</p>
<p>A few files have been taken from the WebAssembly reference interpreter. They are licensed under the Apache License 2.0 and have a different copyright which is stated in the header of the files.</p>
<p>Some code has been taken from the <code>base</code> library from Jane Street. It is licensed under the MIT License and have a different copyright which is stated in the header of the files.</p>
<p>Some code has been taken from the E-ACSL plugin of Frama-C. It is licensed under the GNU Lesser General Public License 2.1 and have a different copyright which is stated in the header of the files.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="funding"><a class="header" href="#funding">Funding</a></h1>
<p>This project was partly funded through the <a href="https://nlnet.nl/core">NGI0 Core</a> Fund, a fund established by <a href="https://nlnet.nl">NLnet</a> with financial support from the European Commission‚Äôs <a href="https://ngi.eu">Next Generation Internet</a> programme. See <a href="https://nlnet.nl/project/OWI">Owi project on NLnet</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="changelog"><a class="header" href="#changelog">Changelog</a></h1>
<p>See <a href="https://github.com/OCamlPro/owi/blob/main/CHANGES.md">CHANGELOG</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="projects-and-people-using-owi"><a class="header" href="#projects-and-people-using-owi">Projects and People Using Owi</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-490ccf04.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/tabs-0c8cb93b.js"></script>
        <script src="theme/highlight-490ccf04.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
